'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib_es6 = require('../external/tslib/tslib.es6.js');
var React = require('react');
var isFunction = require('./isFunction.js');
var isNumber = require('./isNumber.js');
var isPlainObject = require('./isPlainObject.js');
var isUndefined = require('./isUndefined.js');
var normalizeSeries = require('./normalizeSeries.js');
var omitBy = require('./omitBy.js');
var pick = require('./pick.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var limitsPropNames = ['maxX', 'maxY', 'minX', 'minY'];
function proxyChildren(
// Children to enhance with props
children, 
// Series props to use "series" and limits (minX/maxX/minY/maxY) (other props will be ignored!)
seriesProps, 
// Extra props to add to every child (but a child's own props will have higher priority)
extraProps) {
    if (seriesProps === void 0) { seriesProps = {}; }
    if (extraProps === void 0) { extraProps = {}; }
    // 1. Extract defined limits (if any) (minX/maxX/minY/maxY)
    var definedLimits = pick.pick(seriesProps, limitsPropNames);
    // 2. Normalize series
    var normalizedSeriesProps = normalizeSeries.normalizeSeries(seriesProps);
    // 3. Extract real limits (normalization calculates all the limits)
    var calculatedLimits = pick.pick(normalizedSeriesProps, limitsPropNames);
    var normalizedSeries = normalizedSeriesProps.series;
    return React__default['default'].Children.map(children, function (child) {
        if (!child || !React__default['default'].isValidElement(child)) {
            return child;
        }
        // Building the child props
        // 1. Copy child's own props
        var cloneChildProps = tslib_es6.__assign({}, child.props);
        // 2. Merge extraProps (giving priority to the child's original props)
        var childExtraProps = isFunction.isFunction(extraProps) ? extraProps(child) : extraProps;
        Object.keys(childExtraProps).forEach(function (extraPropName) {
            var extraPropValue = childExtraProps[extraPropName];
            if (extraPropName in cloneChildProps) {
                if (isPlainObject.isPlainObject(extraPropValue) && isPlainObject.isPlainObject(cloneChildProps[extraPropName])) {
                    cloneChildProps[extraPropName] = tslib_es6.__assign(tslib_es6.__assign({}, extraPropValue), cloneChildProps[extraPropName]);
                }
            }
            else {
                cloneChildProps[extraPropName] = extraPropValue;
            }
        });
        // 3. Extract defined limits (if any) (minX/maxX/minY/maxY) from the child's original props
        var definedChildLimits = pick.pick(child.props, limitsPropNames);
        // 4. Merge layerWidth/layerHeight and normalize series
        var childNormalizedSeriesProps = normalizeSeries.normalizeSeries(tslib_es6.__assign({ layerWidth: cloneChildProps.layerWidth, layerHeight: cloneChildProps.layerHeight }, child.props));
        // 4. Extract real limits (normalization calculates all the limits)
        var calculatedChildLimits = pick.pick(childNormalizedSeriesProps, limitsPropNames);
        // 6. Combine all together by specific priorities
        cloneChildProps = tslib_es6.__assign(tslib_es6.__assign(tslib_es6.__assign(tslib_es6.__assign(tslib_es6.__assign({}, calculatedLimits), calculatedChildLimits), definedLimits), definedChildLimits), cloneChildProps);
        // 7. Construct series
        var seriesIndex = child.props.seriesIndex;
        if (!child.props.series && normalizedSeries) {
            if (isUndefined.isUndefined(seriesIndex)) {
                cloneChildProps.series = normalizedSeries;
            }
            else if (isNumber.isNumber(seriesIndex)) {
                cloneChildProps.series = [normalizedSeries[seriesIndex]];
            }
            else if (Array.isArray(seriesIndex)) {
                cloneChildProps.series = seriesIndex.map(function (index) { return normalizedSeries[index]; });
            }
            else if (isFunction.isFunction(seriesIndex)) {
                cloneChildProps.series = normalizedSeries.filter(seriesIndex);
            }
            else {
                cloneChildProps.series = normalizedSeries;
            }
        }
        else {
            cloneChildProps.series = childNormalizedSeriesProps.series;
        }
        cloneChildProps.seriesNormalized = true;
        return React__default['default'].cloneElement(child, omitBy.omitBy(cloneChildProps, isUndefined.isUndefined));
    });
}

exports.proxyChildren = proxyChildren;
