import { __assign } from '../external/tslib/tslib.es6.js';
import React from 'react';
import { isFunction } from './isFunction.js';
import { isNumber } from './isNumber.js';
import { isPlainObject } from './isPlainObject.js';
import { isUndefined } from './isUndefined.js';
import { normalizeSeries } from './normalizeSeries.js';
import { omitBy } from './omitBy.js';
import { pick } from './pick.js';

var limitsPropNames = ['maxX', 'maxY', 'minX', 'minY'];
function proxyChildren(
// Children to enhance with props
children, 
// Series props to use "series" and limits (minX/maxX/minY/maxY) (other props will be ignored!)
seriesProps, 
// Extra props to add to every child (but a child's own props will have higher priority)
extraProps) {
    if (seriesProps === void 0) { seriesProps = {}; }
    if (extraProps === void 0) { extraProps = {}; }
    // 1. Extract defined limits (if any) (minX/maxX/minY/maxY)
    var definedLimits = pick(seriesProps, limitsPropNames);
    // 2. Normalize series
    var normalizedSeriesProps = normalizeSeries(seriesProps);
    // 3. Extract real limits (normalization calculates all the limits)
    var calculatedLimits = pick(normalizedSeriesProps, limitsPropNames);
    var normalizedSeries = normalizedSeriesProps.series;
    return React.Children.map(children, function (child) {
        if (!child || !React.isValidElement(child)) {
            return child;
        }
        // Building the child props
        // 1. Copy child's own props
        var cloneChildProps = __assign({}, child.props);
        // 2. Merge extraProps (giving priority to the child's original props)
        var childExtraProps = isFunction(extraProps) ? extraProps(child) : extraProps;
        Object.keys(childExtraProps).forEach(function (extraPropName) {
            var extraPropValue = childExtraProps[extraPropName];
            if (extraPropName in cloneChildProps) {
                if (isPlainObject(extraPropValue) && isPlainObject(cloneChildProps[extraPropName])) {
                    cloneChildProps[extraPropName] = __assign(__assign({}, extraPropValue), cloneChildProps[extraPropName]);
                }
            }
            else {
                cloneChildProps[extraPropName] = extraPropValue;
            }
        });
        // 3. Extract defined limits (if any) (minX/maxX/minY/maxY) from the child's original props
        var definedChildLimits = pick(child.props, limitsPropNames);
        // 4. Merge layerWidth/layerHeight and normalize series
        var childNormalizedSeriesProps = normalizeSeries(__assign({ layerWidth: cloneChildProps.layerWidth, layerHeight: cloneChildProps.layerHeight }, child.props));
        // 4. Extract real limits (normalization calculates all the limits)
        var calculatedChildLimits = pick(childNormalizedSeriesProps, limitsPropNames);
        // 6. Combine all together by specific priorities
        cloneChildProps = __assign(__assign(__assign(__assign(__assign({}, calculatedLimits), calculatedChildLimits), definedLimits), definedChildLimits), cloneChildProps);
        // 7. Construct series
        var seriesIndex = child.props.seriesIndex;
        if (!child.props.series && normalizedSeries) {
            if (isUndefined(seriesIndex)) {
                cloneChildProps.series = normalizedSeries;
            }
            else if (isNumber(seriesIndex)) {
                cloneChildProps.series = [normalizedSeries[seriesIndex]];
            }
            else if (Array.isArray(seriesIndex)) {
                cloneChildProps.series = seriesIndex.map(function (index) { return normalizedSeries[index]; });
            }
            else if (isFunction(seriesIndex)) {
                cloneChildProps.series = normalizedSeries.filter(seriesIndex);
            }
            else {
                cloneChildProps.series = normalizedSeries;
            }
        }
        else {
            cloneChildProps.series = childNormalizedSeriesProps.series;
        }
        cloneChildProps.seriesNormalized = true;
        return React.cloneElement(child, omitBy(cloneChildProps, isUndefined));
    });
}

export { proxyChildren };
