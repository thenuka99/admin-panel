(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.RumbleCharts = {}, global.React));
}(this, (function (exports, React) { 'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var frame = 0, // is an animation frame pending?
        timeout = 0, // is a timeout pending?
        interval = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend we’ve set an alarm, if we haven’t already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout) timeout = clearTimeout(timeout);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval) interval = clearInterval(interval);
      } else {
        if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
        reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
        reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
        reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
        reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
        reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color, {
      copy: function(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb$1(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb$1, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }

    function rgb_formatRgb() {
      var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
      return (a === 1 ? "rgb(" : "rgba(")
          + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
          + Math.max(0, Math.min(255, Math.round(this.b) || 0))
          + (a === 1 ? ")" : ", " + a + ")");
    }

    function hex(value) {
      value = Math.max(0, Math.min(255, Math.round(value) || 0));
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(")
            + (this.h || 0) + ", "
            + (this.s || 0) * 100 + "%, "
            + (this.l || 0) * 100 + "%"
            + (a === 1 ? ")" : ", " + a + ")");
      }
    }));

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    var constant$1 = x => () => x;

    function linear$2(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function gamma(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$2(a, d) : constant$1(isNaN(a) ? b : a);
    }

    var rgb = (function rgbGamma(y) {
      var color = gamma(y);

      function rgb(start, end) {
        var r = color((start = rgb$1(start)).r, (end = rgb$1(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb.gamma = rgbGamma;

      return rgb;
    })(1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function string(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$1(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color(b)) ? (b = c, rgb) : string)
          : b instanceof color ? rgb
          : b instanceof Date ? date
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
          : interpolateNumber)(a, b);
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    function ascending(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(f) {
      let delta = f;
      let compare1 = f;
      let compare2 = f;

      if (f.length === 1) {
        delta = (d, x) => f(d) - x;
        compare1 = ascending;
        compare2 = (d, x) => ascending(f(d), x);
      }

      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function number$1(x) {
      return x === null ? NaN : +x;
    }

    const ascendingBisect = bisector(ascending);
    const bisectRight = ascendingBisect.right;
    bisector(number$1).center;
    var bisect = bisectRight;

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(value);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        let r0 = Math.round(start / step), r1 = Math.round(stop / step);
        if (r0 * step < start) ++r0;
        if (r1 * step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.round(start * step), r1 = Math.round(stop * step);
        if (r0 / step < start) ++r0;
        if (r1 / step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$1(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer() {
      var domain = unit,
          range = unit,
          interpolate$1 = interpolate,
          transform,
          untransform,
          unknown,
          clamp = identity$1,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$1) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate$1 = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$1, rescale()) : clamp !== identity$1;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer()(identity$1, identity$1);
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent$1(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity(x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "−" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer “value” part that can be
            // grouped, and fractional or exponential “suffix” part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale;
    var format;
    var formatPrefix;

    defaultLocale({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      format = locale.format;
      formatPrefix = locale.formatPrefix;
      return locale;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent$1(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear$1() {
      var scale = continuous();

      scale.copy = function() {
        return copy(scale, linear$1());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var schemeCategory10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var schemeAccent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var schemeDark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var schemePaired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var schemePastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var schemePastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var schemeSet1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var schemeSet2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var schemeSet3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var schemeTableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    var TYPE_FUNCTION = 'function';
    function isFunction(value) {
        return typeof value === TYPE_FUNCTION || value instanceof Function;
    }

    var TYPE_STRING = 'string';
    function isString(value) {
        return typeof value === TYPE_STRING || value instanceof String;
    }

    var schemeMap = {
        category10: schemeCategory10,
        category20: [
            '#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c',
            '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5',
            '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f',
            '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5'
        ],
        category20b: [
            '#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939',
            '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39',
            '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b',
            '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6'
        ],
        category20c: [
            '#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d',
            '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476',
            '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc',
            '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9'
        ],
        accent: schemeAccent,
        dark2: schemeDark2,
        paired: schemePaired,
        pastel1: schemePastel1,
        pastel2: schemePastel2,
        set1: schemeSet1,
        set2: schemeSet2,
        set3: schemeSet3,
        tableau10: schemeTableau10
    };
    var defaultScheme = schemeMap.category20;
    var defaultSchemeName = 'category20';
    function colorFunc(colors) {
        if (isFunction(colors)) {
            return colors;
        }
        else if (!colors) {
            return ordinal(defaultScheme);
        }
        else if (isString(colors)) {
            return ordinal(schemeMap[colors]);
        }
        else {
            return ordinal(colors);
        }
    }

    const pi$2 = Math.PI,
        tau$2 = 2 * pi$2,
        epsilon$1 = 1e-6,
        tauEpsilon = tau$2 - epsilon$1;

    function Path() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path;
    }

    Path.prototype = path.prototype = {
      constructor: Path,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$1));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$1) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? We’re done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$2 + tau$2;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$1) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    function constant(x) {
      return function constant() {
        return x;
      };
    }

    var abs = Math.abs;
    var atan2 = Math.atan2;
    var cos = Math.cos;
    var max = Math.max;
    var min = Math.min;
    var sin = Math.sin;
    var sqrt = Math.sqrt;

    var epsilon = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var tau$1 = 2 * pi$1;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin(x) {
      return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function d3Arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null;

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi$1,
            a1 = endAngle.apply(this, arguments) - halfPi$1,
            da = abs(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau$1 - epsilon) {
          context.moveTo(r1 * cos(a0), r1 * sin(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon) {
            context.moveTo(r0 * cos(a1), r0 * sin(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
              rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
          if (rp > epsilon) {
            var p0 = asin(rp / r0 * sin(ap)),
                p1 = asin(rp / r1 * sin(ap));
            if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos(a01),
              y01 = r1 * sin(a01),
              x10 = r0 * cos(a10),
              y10 = r0 * sin(a10);

          // Apply rounded corners?
          if (rc > epsilon) {
            var x11 = r1 * cos(a11),
                y11 = r1 * sin(a11),
                x00 = r0 * cos(a00),
                y00 = r0 * sin(a00),
                oc;

            // Restrict the corner radius according to the sector angle.
            if (da < pi$1 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                  lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min(rc, (r0 - lc) / (kc - 1));
              rc1 = min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon)) context.moveTo(x01, y01);

          // Does the sector’s outer ring have rounded corners?
          else if (rc1 > epsilon) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?
          if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

          // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > epsilon) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
        return [cos(a) * r, sin(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    function array(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x(p) {
      return p[0];
    }

    function y(p) {
      return p[1];
    }

    function d3Line(x$1, y$1) {
      var defined = constant(true),
          context = null,
          curve = curveLinear,
          output = null;

      x$1 = typeof x$1 === "function" ? x$1 : (x$1 === undefined) ? x : constant(x$1);
      y$1 = typeof y$1 === "function" ? y$1 : (y$1 === undefined) ? y : constant(y$1);

      function line(data) {
        var i,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line) : x$1;
      };

      line.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line) : y$1;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function d3Area(x0, y0, y1) {
      var x1 = null,
          defined = constant(true),
          context = null,
          curve = curveLinear,
          output = null;

      x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x : constant(+x0);
      y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant(0) : constant(+y0);
      y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y : constant(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return d3Line().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    var curveRadialLinear = curveRadial(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(d3Line().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = d3Area().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return a;
    }

    var symbolCircle = {
      draw: function(context, size) {
        var r = Math.sqrt(size / pi$1);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau$1);
      }
    };

    var symbolCross = {
      draw: function(context, size) {
        var r = Math.sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    var tan30 = Math.sqrt(1 / 3),
        tan30_2 = tan30 * 2;

    var symbolDiamond = {
      draw: function(context, size) {
        var y = Math.sqrt(size / tan30_2),
            x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var ka = 0.89081309152928522810,
        kr = Math.sin(pi$1 / 10) / Math.sin(7 * pi$1 / 10),
        kx = Math.sin(tau$1 / 10) * kr,
        ky = -Math.cos(tau$1 / 10) * kr;

    var symbolStar = {
      draw: function(context, size) {
        var r = Math.sqrt(size * ka),
            x = kx * r,
            y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (var i = 1; i < 5; ++i) {
          var a = tau$1 * i / 5,
              c = Math.cos(a),
              s = Math.sin(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    var symbolSquare = {
      draw: function(context, size) {
        var w = Math.sqrt(size),
            x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var sqrt3 = Math.sqrt(3);

    var symbolTriangle = {
      draw: function(context, size) {
        var y = -Math.sqrt(size / (sqrt3 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3 * y, -y);
        context.lineTo(sqrt3 * y, -y);
        context.closePath();
      }
    };

    var c = -0.5,
        s = Math.sqrt(3) / 2,
        k = 1 / Math.sqrt(12),
        a = (k / 2 + 1) * 3;

    var symbolWye = {
      draw: function(context, size) {
        var r = Math.sqrt(size / a),
            x0 = r / 2,
            y0 = r * k,
            x1 = x0,
            y1 = r * k + r,
            x2 = -x1,
            y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };

    function symbol(type, size) {
      var context = null;
      type = typeof type === "function" ? type : constant(type || symbolCircle);
      size = typeof size === "function" ? size : constant(size === undefined ? 64 : +size);

      function symbol() {
        var buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop() {}

    function point$2(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$2(this, this._x1, this._y1); // falls through
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function curveBasis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function curveBasisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function curveBasisOpen(context) {
      return new BasisOpen(context);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var curveBundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$1(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$1(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // falls through
          default: point$1(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var curveCardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$1(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var curveCardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$1(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var curveCardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function curveLinearClosed(context) {
      return new LinearClosed(context);
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    (Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function curveStep(context) {
      return new Step(context, 0.5);
    }

    function stepBefore(context) {
      return new Step(context, 0);
    }

    function stepAfter(context) {
      return new Step(context, 1);
    }

    var curves = {
        'linear': curveLinear,
        'linear-closed': curveLinearClosed,
        'step': curveStep,
        'step-before': stepBefore,
        'step-after': stepAfter,
        'basis': curveBasis,
        'basis-open': curveBasisOpen,
        'basis-closed': curveBasisClosed,
        'bundle': curveBundle,
        'cardinal': curveCardinal,
        'cardinal-open': curveCardinalOpen,
        'cardinal-closed': curveCardinalClosed,
        'monotone': monotoneX
    };

    const linear = t => +t;

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent);

    var pi = Math.PI,
        halfPi = pi / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;

    function bounceIn(t) {
      return 1 - bounceOut(1 - t);
    }

    function bounceOut(t) {
      return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude, period);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude, period);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude, period);

    var eases = {
        'linear': linear,
        'poly': polyInOut,
        'quad': quadInOut,
        'cubic': cubicInOut,
        'sin': sinInOut,
        'exp': expInOut,
        'circle': circleInOut,
        'bounce': bounceOut,
        'elastic': elasticOut,
        'back': backInOut,
        'linear-in': linear,
        'poly-in': polyIn,
        'quad-in': quadIn,
        'cubic-in': cubicIn,
        'sin-in': sinIn,
        'exp-in': expIn,
        'circle-in': circleIn,
        'bounce-in': bounceIn,
        'elastic-in': elasticIn,
        'back-in': backIn,
        'linear-out': d3_ease_reverse(linear),
        'poly-out': polyOut,
        'quad-out': quadOut,
        'cubic-out': cubicOut,
        'sin-out': sinOut,
        'exp-out': expOut,
        'circle-out': circleOut,
        'bounce-out': bounceOut,
        'elastic-out': elasticOut,
        'back-out': backOut,
        'linear-in-out': d3_ease_reflect(linear),
        'poly-in-out': polyInOut,
        'quad-in-out': quadInOut,
        'cubic-in-out': cubicInOut,
        'sin-in-out': sinInOut,
        'exp-in-out': expInOut,
        'circle-in-out': circleInOut,
        'bounce-in-out': bounceInOut,
        'elastic-in-out': elasticInOut,
        'back-in-out': backInOut,
        'linear-out-in': d3_ease_reflect(d3_ease_reverse(linear)),
        'poly-out-in': d3_ease_reflect(d3_ease_reverse(polyInOut)),
        'quad-out-in': d3_ease_reflect(d3_ease_reverse(quadInOut)),
        'cubic-out-in': d3_ease_reflect(d3_ease_reverse(cubicInOut)),
        'sin-out-in': d3_ease_reflect(d3_ease_reverse(sinInOut)),
        'exp-out-in': d3_ease_reflect(d3_ease_reverse(expInOut)),
        'circle-out-in': d3_ease_reflect(d3_ease_reverse(circleInOut)),
        'bounce-out-in': d3_ease_reflect(d3_ease_reverse(bounceOut)),
        'elastic-out-in': d3_ease_reflect(d3_ease_reverse(elasticOut)),
        'back-out-in': d3_ease_reflect(d3_ease_reverse(backInOut))
    };
    function d3_ease_reverse(f) {
        return function (t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function (t) {
            return 0.5 * (t < 0.5 ? f(2 * t) : (2 - f(2 - 2 * t)));
        };
    }

    var TYPE_UNDEFINED = 'undefined';
    function isUndefined(value) {
        return typeof value === TYPE_UNDEFINED;
    }

    var showedDeprecationWarning = false;
    function normalizeNumber(number, absolute) {
        if (number === void 0) { number = 0; }
        if (absolute === void 0) { absolute = 0; }
        if (isString(number)) {
            if (number.substr(-1, 1) === '%') {
                number = ((parseFloat(number) || 0) / 100) * absolute;
            }
            else if (number === 'left' || number === 'top') {
                number = 0;
            }
            else if (number === 'right' || number === 'bottom') {
                number = absolute;
            }
            else if (number === 'middle' || number === 'center') {
                number = absolute / 2;
            }
            else {
                number = parseFloat(number) || 0;
            }
        }
        if (number > 0 && number <= 1) {
            if (number > 0 && !showedDeprecationWarning) {
                showedDeprecationWarning = true;
                console.warn("DEPRECATION WARNING. Please write \"" + Math.round(number * 100) + "%\" instead of " + number + ". In the future versions of 'rumble-charts', the latter notation will be removed.");
            }
            number = number * absolute;
        }
        return number;
    }

    var TYPE_NUMBER = 'number';
    function isNumber(value) {
        return typeof value === TYPE_NUMBER || value instanceof Number;
    }

    var TOP = 'top';
    var BOTTOM = 'bottom';
    var MIDDLE = 'middle';
    var LEFT = 'left';
    var RIGHT = 'right';
    var CENTER = 'center';
    var HORIZONTAL = [TOP, BOTTOM, MIDDLE];
    var VERTICAL = [LEFT, RIGHT, CENTER];
    function getCoords(position, layerWidth, layerHeight, width, height) {
        if (layerWidth === void 0) { layerWidth = 0; }
        if (layerHeight === void 0) { layerHeight = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (isString(position)) {
            position = position.trim().split(' ').map(function (value) { return value.trim(); });
        }
        if (Array.isArray(position)) {
            var cleanPosition = position.map(function (pos) { return isString(pos) ? pos.trim().toLowerCase() : pos; });
            var _x = cleanPosition[0], _y = cleanPosition[1];
            if (isString(cleanPosition[0]) && HORIZONTAL.indexOf(cleanPosition[0]) !== -1) {
                _y = cleanPosition[0];
            }
            if (isString(cleanPosition[1]) && VERTICAL.indexOf(cleanPosition[1]) !== -1) {
                _x = cleanPosition[1];
            }
            var result = {
                x: 0,
                y: 0
            };
            if (isString(_x)) {
                if (_x === LEFT) {
                    result.x = 0;
                }
                else if (_x === RIGHT) {
                    result.x = layerWidth - width;
                }
                else if (_x === CENTER) {
                    result.x = (layerWidth - width) / 2;
                }
                else {
                    result.x = normalizeNumber(_x, layerWidth);
                }
            }
            else if (isNumber(_x)) {
                result.x = _x;
            }
            else if (isUndefined(_x)) {
                result.x = 0;
            }
            if (isString(_y)) {
                if (_y === TOP) {
                    result.y = 0;
                }
                else if (_y === BOTTOM) {
                    result.y = layerHeight - height;
                }
                else if (_y === MIDDLE) {
                    result.y = (layerHeight - height) / 2;
                }
                else {
                    result.y = normalizeNumber(_y, layerHeight);
                }
            }
            else if (isNumber(_y)) {
                result.y = _y;
            }
            else if (isUndefined(_y)) {
                result.y = 0;
            }
            return result;
        }
        else {
            return { x: 0, y: 0 };
        }
    }

    var TYPE_OBJECT = 'object';
    function isObject(value) {
        return typeof value === TYPE_OBJECT;
    }

    function isPlainObject(value) {
        return isObject(value) && !Array.isArray(value) && !isFunction(value) && value !== null;
    }

    function omitBy(input, predicate) {
        var output = {};
        for (var key in input) {
            if (!predicate(input[key], key)) {
                output[key] = input[key];
            }
        }
        return output;
    }

    var isInvalidLimit = function (value) {
        return isUndefined(value) || value === Infinity || value === -Infinity;
    };
    function normalizeSeries(props) {
        var _a;
        var maxX = -Infinity, maxY = -Infinity, minX = Infinity, minY = Infinity;
        var series = (_a = props === null || props === void 0 ? void 0 : props.series) === null || _a === void 0 ? void 0 : _a.map(function (series) {
            var _a;
            var data = (_a = series.data) === null || _a === void 0 ? void 0 : _a.map(function (item, index) {
                var d;
                if (!props.seriesNormalized) {
                    d = {};
                    if (isNumber(item)) {
                        d.x = index;
                        d.y = item;
                    }
                    else if (Array.isArray(item)) {
                        d.x = item[0];
                        d.y = item[1];
                    }
                    else {
                        d = item || {};
                        if (isUndefined(d.x)) {
                            d.x = index;
                        }
                    }
                }
                else {
                    d = item;
                }
                if (isUndefined(props.maxX)) {
                    maxX = Math.max(maxX, d.x || 0);
                }
                if (isUndefined(props.maxY)) {
                    maxY = Math.max(maxY, d.y || 0);
                }
                if (isUndefined(props.minX)) {
                    minX = Math.min(minX, d.x || 0);
                }
                if (isUndefined(props.minY)) {
                    minY = Math.min(minY, d.y || 0);
                }
                return d;
            });
            return __assign(__assign({}, series), { data: data });
        });
        if (series && series.length === 0) {
            series = undefined;
        }
        if (!isUndefined(props.maxX)) {
            maxX = props.maxX;
        }
        if (!isUndefined(props.maxY)) {
            maxY = props.maxY;
        }
        if (!isUndefined(props.minX)) {
            minX = props.minX;
        }
        if (!isUndefined(props.minY)) {
            minY = props.minY;
        }
        return omitBy({
            seriesNormalized: true,
            series: series,
            maxX: maxX,
            maxY: maxY,
            minX: minX,
            minY: minY
        }, isInvalidLimit);
    }

    function omit(input, fields) {
        var output = __assign({}, input);
        fields.forEach(function (field) {
            if (field in output) {
                delete output[field];
            }
        });
        return output;
    }

    function pick(input, fields) {
        var output = {};
        fields.forEach(function (field) {
            if (field in input) {
                output[field] = input[field];
            }
        });
        return output;
    }

    var limitsPropNames = ['maxX', 'maxY', 'minX', 'minY'];
    function proxyChildren(
    // Children to enhance with props
    children, 
    // Series props to use "series" and limits (minX/maxX/minY/maxY) (other props will be ignored!)
    seriesProps, 
    // Extra props to add to every child (but a child's own props will have higher priority)
    extraProps) {
        if (seriesProps === void 0) { seriesProps = {}; }
        if (extraProps === void 0) { extraProps = {}; }
        // 1. Extract defined limits (if any) (minX/maxX/minY/maxY)
        var definedLimits = pick(seriesProps, limitsPropNames);
        // 2. Normalize series
        var normalizedSeriesProps = normalizeSeries(seriesProps);
        // 3. Extract real limits (normalization calculates all the limits)
        var calculatedLimits = pick(normalizedSeriesProps, limitsPropNames);
        var normalizedSeries = normalizedSeriesProps.series;
        return React__default['default'].Children.map(children, function (child) {
            if (!child || !React__default['default'].isValidElement(child)) {
                return child;
            }
            // Building the child props
            // 1. Copy child's own props
            var cloneChildProps = __assign({}, child.props);
            // 2. Merge extraProps (giving priority to the child's original props)
            var childExtraProps = isFunction(extraProps) ? extraProps(child) : extraProps;
            Object.keys(childExtraProps).forEach(function (extraPropName) {
                var extraPropValue = childExtraProps[extraPropName];
                if (extraPropName in cloneChildProps) {
                    if (isPlainObject(extraPropValue) && isPlainObject(cloneChildProps[extraPropName])) {
                        cloneChildProps[extraPropName] = __assign(__assign({}, extraPropValue), cloneChildProps[extraPropName]);
                    }
                }
                else {
                    cloneChildProps[extraPropName] = extraPropValue;
                }
            });
            // 3. Extract defined limits (if any) (minX/maxX/minY/maxY) from the child's original props
            var definedChildLimits = pick(child.props, limitsPropNames);
            // 4. Merge layerWidth/layerHeight and normalize series
            var childNormalizedSeriesProps = normalizeSeries(__assign({ layerWidth: cloneChildProps.layerWidth, layerHeight: cloneChildProps.layerHeight }, child.props));
            // 4. Extract real limits (normalization calculates all the limits)
            var calculatedChildLimits = pick(childNormalizedSeriesProps, limitsPropNames);
            // 6. Combine all together by specific priorities
            cloneChildProps = __assign(__assign(__assign(__assign(__assign({}, calculatedLimits), calculatedChildLimits), definedLimits), definedChildLimits), cloneChildProps);
            // 7. Construct series
            var seriesIndex = child.props.seriesIndex;
            if (!child.props.series && normalizedSeries) {
                if (isUndefined(seriesIndex)) {
                    cloneChildProps.series = normalizedSeries;
                }
                else if (isNumber(seriesIndex)) {
                    cloneChildProps.series = [normalizedSeries[seriesIndex]];
                }
                else if (Array.isArray(seriesIndex)) {
                    cloneChildProps.series = seriesIndex.map(function (index) { return normalizedSeries[index]; });
                }
                else if (isFunction(seriesIndex)) {
                    cloneChildProps.series = normalizedSeries.filter(seriesIndex);
                }
                else {
                    cloneChildProps.series = normalizedSeries;
                }
            }
            else {
                cloneChildProps.series = childNormalizedSeriesProps.series;
            }
            cloneChildProps.seriesNormalized = true;
            return React__default['default'].cloneElement(child, omitBy(cloneChildProps, isUndefined));
        });
    }

    function sortBy(list, field) {
        var copy = __spreadArray([], list);
        copy.sort(function (a, b) {
            if (a[field] === b[field]) {
                return 0;
            }
            return a[field] > b[field] ? 1 : -1;
        });
        return copy;
    }

    function reverse(_a) {
        var series = _a.series, seriesNormalized = _a.seriesNormalized, minX = _a.minX, maxX = _a.maxX, maxY = _a.maxY, minY = _a.minY;
        series = Array.isArray(series) ? __spreadArray([], series).reverse() : series;
        return {
            series: series,
            seriesNormalized: seriesNormalized,
            maxX: maxX,
            maxY: maxY,
            minX: minX,
            minY: minY
        };
    }

    function rotate(props) {
        var series = props.series, seriesNormalized = props.seriesNormalized, minX = props.minX, maxX = props.maxX, maxY = props.maxY, minY = props.minY;
        var scaleX = props.scaleX, scaleY = props.scaleY;
        var paddingLeft = scaleX.paddingLeft, paddingRight = scaleX.paddingRight;
        var paddingTop = scaleY.paddingTop, paddingBottom = scaleY.paddingBottom;
        scaleX = __assign({}, scaleX);
        scaleY = __assign({}, scaleY);
        scaleX.paddingLeft = paddingTop;
        scaleX.paddingRight = paddingBottom;
        scaleX.swap = !scaleX.swap;
        scaleY.paddingTop = paddingLeft;
        scaleY.paddingBottom = paddingRight;
        scaleY.swap = !scaleY.swap;
        scaleY.direction = -1;
        return {
            series: series,
            seriesNormalized: seriesNormalized,
            maxX: maxX,
            maxY: maxY,
            minX: minX,
            minY: minY,
            scaleX: scaleX,
            scaleY: scaleY
        };
    }

    function sort(props, _a) {
        var _b = _a === void 0 ? {} : _a, direction = _b.direction;
        direction = (isString(direction) ? direction.trim().toLowerCase() : 'asc');
        var seriesNormalized = props.seriesNormalized, maxX = props.maxX, maxY = props.maxY, minX = props.minX, minY = props.minY;
        var series = props.series;
        series = series === null || series === void 0 ? void 0 : series.map(function (series) {
            var _a;
            var newSeries = { data: [] };
            newSeries.data = sortBy(series.data, 'y');
            if (direction === 'desc') {
                newSeries.data.reverse();
            }
            newSeries.data = (_a = newSeries.data) === null || _a === void 0 ? void 0 : _a.map(function (point, pointIndex) {
                var newPoint = {
                    realX: point.x,
                    x: pointIndex
                };
                return __assign(__assign({}, point), newPoint);
            });
            newSeries.data = sortBy(newSeries.data, 'realX');
            return __assign(__assign({}, series), newSeries);
        });
        return {
            series: series,
            seriesNormalized: seriesNormalized,
            maxX: maxX,
            maxY: maxY,
            minX: minX,
            minY: minY
        };
    }

    function stack(props, options) {
        if (options === void 0) { options = {}; }
        var normalize = (options || {}).normalize;
        var series = props.series, maxY = props.maxY, minY = props.minY;
        var seriesNormalized = props.seriesNormalized, maxX = props.maxX, minX = props.minX;
        var stackedY = [], lowestY = [];
        series = series === null || series === void 0 ? void 0 : series.map(function (series) {
            var _a;
            var newSeries = {
                data: (_a = series.data) === null || _a === void 0 ? void 0 : _a.map(function (point, pointIndex) {
                    stackedY[pointIndex] = stackedY[pointIndex] || 0;
                    if (isUndefined(lowestY[pointIndex])) {
                        lowestY[pointIndex] = stackedY[pointIndex];
                    }
                    var newPoint = {
                        y0: stackedY[pointIndex],
                        y: stackedY[pointIndex] + point.y
                    };
                    stackedY[pointIndex] = newPoint.y;
                    return __assign(__assign({}, point), newPoint);
                })
            };
            return __assign(__assign({}, series), newSeries);
        });
        minY = Math.min.apply(Math, __spreadArray([minY || 0], lowestY));
        var stackedMaxY = Math.max.apply(Math, stackedY);
        maxY = Math.max(stackedMaxY, maxY || 0);
        if (normalize) {
            var ratios_1 = stackedY.map(function (y) { return stackedMaxY / y; });
            series = series === null || series === void 0 ? void 0 : series.map(function (series) {
                var _a;
                var newSeries = {
                    data: (_a = series.data) === null || _a === void 0 ? void 0 : _a.map(function (point, pointIndex) {
                        var newPoint = {
                            y0: (point.y0 || 0) * ratios_1[pointIndex],
                            y: point.y * ratios_1[pointIndex]
                        };
                        return __assign(__assign({}, point), newPoint);
                    })
                };
                return __assign(__assign({}, series), newSeries);
            });
        }
        return {
            series: series,
            seriesNormalized: seriesNormalized,
            maxX: maxX,
            maxY: maxY,
            minX: minX,
            minY: minY
        };
    }

    function stackNormalized(props) {
        return stack(props, {
            normalize: true
        });
    }

    function transpose(props) {
        var series = props.series, seriesNormalized = props.seriesNormalized, minX = props.minX, maxY = props.maxY, minY = props.minY;
        var maxX = 0;
        var newSeries = [];
        series === null || series === void 0 ? void 0 : series.forEach(function (series, seriesIndex) {
            var _a;
            (_a = series.data) === null || _a === void 0 ? void 0 : _a.forEach(function (point, pointIndex) {
                newSeries[pointIndex] = newSeries[pointIndex] || { data: [] };
                maxX = Math.max(maxX, seriesIndex);
                newSeries[pointIndex].data[seriesIndex] = __assign(__assign({}, point), { realX: point.x, x: seriesIndex });
            });
        });
        return {
            series: newSeries,
            seriesNormalized: seriesNormalized,
            maxX: maxX,
            maxY: maxY,
            minX: minX,
            minY: minY
        };
    }

    function unstack(props) {
        var series = props.series, seriesNormalized = props.seriesNormalized, maxX = props.maxX, maxY = props.maxY, minX = props.minX, minY = props.minY;
        var newSeries = series
            ? series.map(function (series) {
                var _a;
                var newSeries = {
                    data: (_a = series.data) === null || _a === void 0 ? void 0 : _a.map(function (point) {
                        var newPoint = omit(point, ['y0', 'y']);
                        newPoint.y = point.y - point.y0;
                        return newPoint;
                    })
                };
                return __assign(__assign({}, series), newSeries);
            }, [])
            : [];
        return {
            series: newSeries,
            seriesNormalized: seriesNormalized,
            maxX: maxX,
            maxY: maxY,
            minX: minX,
            minY: minY
        };
    }

    var transforms = /*#__PURE__*/Object.freeze({
        __proto__: null,
        reverse: reverse,
        rotate: rotate,
        sort: sort,
        stack: stack,
        stackNormalized: stackNormalized,
        transpose: transpose,
        unstack: unstack
    });

    function transform(props, method, options) {
        if (options === void 0) { options = undefined; }
        if (!Array.isArray(method)) {
            method = [method];
        }
        return method.reduce(function (props, method) {
            if (isString(method)) {
                if (isFunction(transforms[method])) {
                    return __assign(__assign({}, props), transforms[method](props, options));
                }
                else {
                    return props;
                }
            }
            else if (isFunction(method)) {
                return __assign(__assign({}, props), method(props, options));
            }
            else if (isObject(method)) {
                return transform(props, method.method, method.options);
            }
            else {
                return props;
            }
        }, props);
    }

    function value(attribute, args) {
        if (Array.isArray(attribute)) {
            var result = void 0;
            for (var _i = 0, attribute_1 = attribute; _i < attribute_1.length; _i++) {
                var attr = attribute_1[_i];
                attr = isFunction(attr) ? attr(args) : attr;
                if (isObject(attr) && !Array.isArray(attr) && !('_owner' in attr) && !('props' in attr)) {
                    result = __assign(__assign({}, attr), (result || {}));
                }
                else if (!isUndefined(attr) && attr !== null) {
                    result = attr;
                    break;
                }
            }
            return result;
        }
        else {
            return isFunction(attribute) ? attribute(args) : attribute;
        }
    }

    /**
     * Animates (actually interpolates) your `series` data. Very useful when you want to have
     * simple and nice transitions between data state.
     *
     * As a wrapper it takes `series` obtained from its parent and gives it to its children.
     *
     * By default, `interpolateProps` list contains all the common props:
     * ['series', 'maxX', 'maxY', 'minX', 'minY', 'layerWidth', 'layerHeight'].
     * Though, sometimes it makes a lot of sense to interpolate only `series`. Especially, when the
     * components wrapped by `<Animate>` are "jumping". Also, you can explicitly define `minY` as a prop
     * to make the limits stable (and therefore prevent the "jumping" effect)
     */
    function Animate(props) {
        var _a = props.interpolateProps, interpolateProps = _a === void 0 ? ['series', 'maxX', 'maxY', 'minX', 'minY', 'layerWidth', 'layerHeight'] : _a, _b = props.duration, duration = _b === void 0 ? 500 : _b, _c = props.ease, ease = _c === void 0 ? 'linear' : _c, _d = props.tag, tag = _d === void 0 ? 'g' : _d, onStart = props.onStart, onEnd = props.onEnd, onCancel = props.onCancel, logFPS = props.logFPS, pickProps = __rest(props, ["interpolateProps", "duration", "ease", "tag", "onStart", "onEnd", "onCancel", "logFPS"]);
        var _e = React.useState(function () { return (__assign(__assign({}, pickProps), normalizeSeries(pickProps))); }), state = _e[0], setState = _e[1];
        var prevPropsRef = React.useRef(props);
        var newPropsRef = React.useRef();
        newPropsRef.current = React.useMemo(function () {
            var newProps = Object.keys(pickProps).reduce(function (newProps, propName) {
                var _a;
                if (pickProps[propName] !== ((_a = prevPropsRef.current) === null || _a === void 0 ? void 0 : _a[propName])) {
                    newProps[propName] = pickProps[propName];
                }
                return newProps;
            }, {});
            return Object.keys(newProps).length > 0 ? newProps : null;
        }, [props !== prevPropsRef.current]) || newPropsRef.current;
        prevPropsRef.current = props;
        React.useEffect(function () {
            var newProps = newPropsRef.current;
            if (!newProps) {
                return;
            }
            var interpolate$1 = interpolate(pick(state, interpolateProps), pick(__assign(__assign({}, newProps), normalizeSeries(newProps)), interpolateProps));
            var easeFunc = isString(ease) ?
                eases[ease] :
                (isFunction(ease) ? ease : eases['linear']);
            onStart && onStart();
            var i = 0;
            var _timer = timer(function (p) {
                i++;
                if (p >= duration) {
                    p = duration;
                    setState(function (state) { return (__assign(__assign({}, state), interpolate$1(easeFunc(p / duration)))); });
                    onEnd && onEnd();
                    if (logFPS) {
                        console.warn(i * (1000 / duration) + 'fps; ' + i + ' frames in ' + duration + 'ms');
                    }
                    _timer.stop();
                }
                else {
                    setState(function (state) { return (__assign(__assign({}, state), interpolate$1(easeFunc(p / duration)))); });
                }
            });
            return function () {
                onCancel && onCancel();
                _timer.stop();
            };
        }, [newPropsRef.current]);
        return React__default['default'].createElement(tag, { className: pickProps.className }, proxyChildren(pickProps.children, omitBy(state, isUndefined), {
            layerWidth: state.layerWidth,
            layerHeight: state.layerHeight,
            scaleX: pickProps.scaleX,
            scaleY: pickProps.scaleY
        }));
    }

    /**
     * Renders bars for your bar chart.
     */
    function Bars(props) {
        var _a;
        var className = props.className, style = props.style, _b = props.colors, colors = _b === void 0 ? defaultSchemeName : _b, opacity = props.opacity;
        var x = props.scaleX.factory(props);
        var y = props.scaleY.factory(props);
        var domainX = x.domain();
        var naturalDirection = domainX[1] > domainX[0];
        if (domainX[0] === props.minX || domainX[0] === props.maxX) {
            x.domain([domainX[0] + (naturalDirection ? -0.5 : 0.5), domainX[1]]);
            domainX = x.domain();
        }
        if (domainX[1] === props.minX || domainX[1] === props.maxX) {
            x.domain([domainX[0], domainX[1] + (naturalDirection ? 0.5 : -0.5)]);
        }
        var baseWidth = Math.abs(x(1) - x(0));
        var _y0 = y(0);
        var color = colorFunc(colors);
        var _c = React.useMemo(function () {
            var _a = props.innerPadding, innerPadding = _a === void 0 ? 0 : _a, _b = props.groupPadding, groupPadding = _b === void 0 ? 0 : _b;
            return {
                innerPadding: normalizeNumber(value(innerPadding, props), props.layerWidth),
                groupPadding: normalizeNumber(value(groupPadding, props), props.layerWidth)
            };
        }, [props.innerPadding, props.groupPadding, props.layerWidth]), innerPadding = _c.innerPadding, groupPadding = _c.groupPadding;
        var barWidth = React.useMemo(function () {
            if (props.barWidth) {
                return normalizeNumber(value(props.barWidth, props), props.layerWidth);
            }
            else {
                if (props.combined) {
                    return baseWidth - innerPadding;
                }
                else {
                    return (baseWidth - groupPadding) / (props.series || []).length - innerPadding;
                }
            }
        }, [
            props.barWidth, props.layerWidth, innerPadding, groupPadding,
            props.combined, (props.series || []).length, baseWidth
        ]);
        var renderBar = function (x, y, width, height, seriesIndex, pointIndex, point) {
            var series = props.series[seriesIndex];
            if ('barVisible' in props) {
                var barVisible = value(props.barVisible, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
                if (!barVisible) {
                    return;
                }
            }
            var groupStyle = value(props.groupStyle, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
            var d = (props.scaleX.swap || props.scaleY.swap) ?
                ('M0,' + (-height / 2) + ' h' + (width) + ' v' + height + ' h' + (-width) + ' Z') :
                ('M' + (-width / 2) + ',0 v' + height + ' h' + width + ' v' + (-height) + ' Z');
            var barAttributes = value(props.barAttributes, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
            var barStyle = value([point.style, series.style, props.barStyle], {
                seriesIndex: seriesIndex,
                pointIndex: pointIndex,
                point: point,
                series: series,
                props: props
            });
            return React__default['default'].createElement("g", { key: pointIndex, className: className && (className + '-bar ' + className + '-bar-' + pointIndex), transform: 'translate(' + x + ' ' + y + ')', style: groupStyle },
                React__default['default'].createElement("path", __assign({ style: barStyle, fill: point.color || series.color || color(seriesIndex), fillOpacity: point.opacity, d: d }, barAttributes)));
        };
        var renderSeries = function (series, index) {
            if ('seriesVisible' in props) {
                var seriesVisible = value(props.seriesVisible, { seriesIndex: index, series: series, props: props });
                if (!seriesVisible) {
                    return;
                }
            }
            var seriesAttributes = value(props.seriesAttributes, { seriesIndex: index, series: series, props: props });
            var seriesStyle = value(props.seriesStyle, { seriesIndex: index, series: series, props: props });
            var deltaX = 0;
            if (!props.combined) {
                deltaX = barWidth * index -
                    (props.series.length - 1) * 0.5 * barWidth +
                    (index - (props.series.length - 1) / 2) * innerPadding;
            }
            return React__default['default'].createElement("g", __assign({ key: index, className: className && (className + '-series ' + className + '-series-' + index), opacity: series.opacity, style: seriesStyle }, seriesAttributes), series && series.data.map(function (point, pointIndex) {
                var y0 = point.y0 ? y(point.y0) : _y0;
                var y1 = y(point.y);
                var x1 = x(point.x) + deltaX * (props.scaleX.direction || 1);
                if (props.scaleX.swap || props.scaleY.swap) {
                    return renderBar(y1, x1, y0 - y1, barWidth, index, pointIndex, point);
                }
                else {
                    return renderBar(x1, y1, barWidth, y0 - y1, index, pointIndex, point);
                }
            }));
        };
        return (React__default['default'].createElement("g", { className: className, style: style, opacity: opacity }, (_a = props.series) === null || _a === void 0 ? void 0 : _a.map(renderSeries)));
    }

    /**
     * Every chart should start with `<Chart>` component. It serves to set sizes (`width` and `height`)
     * and to wrap all another components:
     * - [Graphics](#graphics)
     * - [Wrappers](#wrappers)
     * - [Helpers](#helpers)
     *
     * Also read more about [hidden props](#magic--hidden-props).
     */
    function Chart(allProps) {
        var _a = allProps.series, series = _a === void 0 ? [] : _a, _b = allProps.tag, tag = _b === void 0 ? 'svg' : _b, width = allProps.width, height = allProps.height, _c = allProps.layerWidth, layerWidth = _c === void 0 ? width : _c, _d = allProps.layerHeight, layerHeight = _d === void 0 ? height : _d, _e = allProps.viewBox, viewBox = _e === void 0 ? "0 0 " + layerWidth + " " + layerHeight : _e, _f = allProps.scaleX, scaleX = _f === void 0 ? {} : _f, _g = allProps.scaleY, scaleY = _g === void 0 ? {} : _g, minX = allProps.minX, minY = allProps.minY, maxX = allProps.maxX, maxY = allProps.maxY, children = allProps.children, props = __rest(allProps, ["series", "tag", "width", "height", "layerWidth", "layerHeight", "viewBox", "scaleX", "scaleY", "minX", "minY", "maxX", "maxY", "children"]);
        var _layerWidth = layerWidth;
        var _layerHeight = layerHeight;
        if (viewBox) {
            var viewBoxTotal = viewBox.split(' ').map(function (value) { return parseInt(value); });
            _layerWidth = _layerWidth || Number(viewBoxTotal[2]);
            _layerHeight = _layerHeight || Number(viewBoxTotal[3]);
        }
        if (!isNumber(_layerWidth)) {
            throw "Props \"width\" (as number), \"layerWidth\" or \"viewBox\" expected for <Chart> component. " + JSON.stringify(_layerWidth) + " received instead.";
        }
        if (!isNumber(_layerHeight)) {
            throw "Props \"height\" (as number), \"layerHeight\" or \"viewBox\" expected for <Chart> component. " + JSON.stringify(_layerHeight) + " received instead.";
        }
        var newChildren = proxyChildren(children, omitBy({ series: series, minX: minX, minY: minY, maxX: maxX, maxY: maxY }, isUndefined), {
            layerWidth: _layerWidth,
            layerHeight: _layerHeight,
            scaleX: __assign({ direction: 1, paddingStart: 0.5, paddingEnd: 0.5, paddingLeft: 0, paddingRight: 0, factory: function (_a) {
                    var _b = _a.layerWidth, layerWidth = _b === void 0 ? 0 : _b, _c = _a.layerHeight, layerHeight = _c === void 0 ? 0 : _c, _d = _a.scaleX, scaleX = _d === void 0 ? {} : _d, _e = _a.minX, minX = _e === void 0 ? 0 : _e, _f = _a.maxX, maxX = _f === void 0 ? 0 : _f;
                    var _g = scaleX.paddingStart, paddingStart = _g === void 0 ? 0.5 : _g, _h = scaleX.paddingEnd, paddingEnd = _h === void 0 ? 0.5 : _h, _j = scaleX.paddingLeft, paddingLeft = _j === void 0 ? 0 : _j, _k = scaleX.paddingRight, paddingRight = _k === void 0 ? 0 : _k, _l = scaleX.direction, direction = _l === void 0 ? 1 : _l, swap = scaleX.swap;
                    if (swap) {
                        layerWidth = layerHeight;
                    }
                    minX = minX - paddingStart;
                    maxX = maxX + paddingEnd;
                    return linear$1()
                        .range([
                        normalizeNumber(paddingLeft, layerWidth),
                        layerWidth - normalizeNumber(paddingRight, layerWidth)
                    ])
                        .domain(direction >= 0 ? [minX, maxX] : [maxX, minX]);
                } }, scaleX),
            scaleY: __assign({ direction: 1, paddingStart: 0, paddingEnd: 0, paddingTop: 0, paddingBottom: 0, factory: function (_a) {
                    var _b = _a.layerWidth, layerWidth = _b === void 0 ? 0 : _b, _c = _a.layerHeight, layerHeight = _c === void 0 ? 0 : _c, _d = _a.scaleY, scaleY = _d === void 0 ? {} : _d, _e = _a.minY, minY = _e === void 0 ? 0 : _e, _f = _a.maxY, maxY = _f === void 0 ? 0 : _f;
                    var _g = scaleY.paddingStart, paddingStart = _g === void 0 ? 0 : _g, _h = scaleY.paddingEnd, paddingEnd = _h === void 0 ? 0 : _h, _j = scaleY.paddingBottom, paddingBottom = _j === void 0 ? 0 : _j, _k = scaleY.paddingTop, paddingTop = _k === void 0 ? 0 : _k, _l = scaleY.direction, direction = _l === void 0 ? 1 : _l, swap = scaleY.swap;
                    if (swap) {
                        layerHeight = layerWidth;
                    }
                    minY = minY - paddingStart;
                    maxY = maxY + paddingEnd;
                    return linear$1()
                        .range([
                        layerHeight - normalizeNumber(paddingBottom, layerHeight),
                        normalizeNumber(paddingTop, layerHeight)
                    ])
                        .domain(direction >= 0 ? [minY, maxY] : [maxY, minY]);
                } }, scaleY)
        });
        return React__default['default'].createElement(tag, __assign(__assign({}, props), { width: width, height: height, viewBox: viewBox }), newChildren);
    }

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function commonjsRequire (path) {
    	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }

    var d3_layout_cloud = {exports: {}};

    (function (module, exports) {
    (function(f){{module.exports=f();}})(function(){return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof commonjsRequire=="function"&&commonjsRequire;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof commonjsRequire=="function"&&commonjsRequire;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    // Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/
    // Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf

    var dispatch = require("d3-dispatch").dispatch;

    var cloudRadians = Math.PI / 180,
        cw = 1 << 11 >> 5,
        ch = 1 << 11;

    module.exports = function() {
      var size = [256, 256],
          text = cloudText,
          font = cloudFont,
          fontSize = cloudFontSize,
          fontStyle = cloudFontNormal,
          fontWeight = cloudFontNormal,
          rotate = cloudRotate,
          padding = cloudPadding,
          spiral = archimedeanSpiral,
          words = [],
          timeInterval = Infinity,
          event = dispatch("word", "end"),
          timer = null,
          random = Math.random,
          cloud = {},
          canvas = cloudCanvas;

      cloud.canvas = function(_) {
        return arguments.length ? (canvas = functor(_), cloud) : canvas;
      };

      cloud.start = function() {
        var contextAndRatio = getContext(canvas()),
            board = zeroArray((size[0] >> 5) * size[1]),
            bounds = null,
            n = words.length,
            i = -1,
            tags = [],
            data = words.map(function(d, i) {
              d.text = text.call(this, d, i);
              d.font = font.call(this, d, i);
              d.style = fontStyle.call(this, d, i);
              d.weight = fontWeight.call(this, d, i);
              d.rotate = rotate.call(this, d, i);
              d.size = ~~fontSize.call(this, d, i);
              d.padding = padding.call(this, d, i);
              return d;
            }).sort(function(a, b) { return b.size - a.size; });

        if (timer) clearInterval(timer);
        timer = setInterval(step, 0);
        step();

        return cloud;

        function step() {
          var start = Date.now();
          while (Date.now() - start < timeInterval && ++i < n && timer) {
            var d = data[i];
            d.x = (size[0] * (random() + .5)) >> 1;
            d.y = (size[1] * (random() + .5)) >> 1;
            cloudSprite(contextAndRatio, d, data, i);
            if (d.hasText && place(board, d, bounds)) {
              tags.push(d);
              event.call("word", cloud, d);
              if (bounds) cloudBounds(bounds, d);
              else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];
              // Temporary hack
              d.x -= size[0] >> 1;
              d.y -= size[1] >> 1;
            }
          }
          if (i >= n) {
            cloud.stop();
            event.call("end", cloud, tags, bounds);
          }
        }
      };

      cloud.stop = function() {
        if (timer) {
          clearInterval(timer);
          timer = null;
        }
        return cloud;
      };

      function getContext(canvas) {
        canvas.width = canvas.height = 1;
        var ratio = Math.sqrt(canvas.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
        canvas.width = (cw << 5) / ratio;
        canvas.height = ch / ratio;

        var context = canvas.getContext("2d");
        context.fillStyle = context.strokeStyle = "red";
        context.textAlign = "center";

        return {context: context, ratio: ratio};
      }

      function place(board, tag, bounds) {
        [{x: 0, y: 0}, {x: size[0], y: size[1]}];
            var startX = tag.x,
            startY = tag.y,
            maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
            s = spiral(size),
            dt = random() < .5 ? 1 : -1,
            t = -dt,
            dxdy,
            dx,
            dy;

        while (dxdy = s(t += dt)) {
          dx = ~~dxdy[0];
          dy = ~~dxdy[1];

          if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;

          tag.x = startX + dx;
          tag.y = startY + dy;

          if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||
              tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;
          // TODO only check for collisions within current bounds.
          if (!bounds || !cloudCollide(tag, board, size[0])) {
            if (!bounds || collideRects(tag, bounds)) {
              var sprite = tag.sprite,
                  w = tag.width >> 5,
                  sw = size[0] >> 5,
                  lx = tag.x - (w << 4),
                  sx = lx & 0x7f,
                  msx = 32 - sx,
                  h = tag.y1 - tag.y0,
                  x = (tag.y + tag.y0) * sw + (lx >> 5),
                  last;
              for (var j = 0; j < h; j++) {
                last = 0;
                for (var i = 0; i <= w; i++) {
                  board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
                }
                x += sw;
              }
              delete tag.sprite;
              return true;
            }
          }
        }
        return false;
      }

      cloud.timeInterval = function(_) {
        return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;
      };

      cloud.words = function(_) {
        return arguments.length ? (words = _, cloud) : words;
      };

      cloud.size = function(_) {
        return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;
      };

      cloud.font = function(_) {
        return arguments.length ? (font = functor(_), cloud) : font;
      };

      cloud.fontStyle = function(_) {
        return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;
      };

      cloud.fontWeight = function(_) {
        return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;
      };

      cloud.rotate = function(_) {
        return arguments.length ? (rotate = functor(_), cloud) : rotate;
      };

      cloud.text = function(_) {
        return arguments.length ? (text = functor(_), cloud) : text;
      };

      cloud.spiral = function(_) {
        return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;
      };

      cloud.fontSize = function(_) {
        return arguments.length ? (fontSize = functor(_), cloud) : fontSize;
      };

      cloud.padding = function(_) {
        return arguments.length ? (padding = functor(_), cloud) : padding;
      };

      cloud.random = function(_) {
        return arguments.length ? (random = _, cloud) : random;
      };

      cloud.on = function() {
        var value = event.on.apply(event, arguments);
        return value === event ? cloud : value;
      };

      return cloud;
    };

    function cloudText(d) {
      return d.text;
    }

    function cloudFont() {
      return "serif";
    }

    function cloudFontNormal() {
      return "normal";
    }

    function cloudFontSize(d) {
      return Math.sqrt(d.value);
    }

    function cloudRotate() {
      return (~~(Math.random() * 6) - 3) * 30;
    }

    function cloudPadding() {
      return 1;
    }

    // Fetches a monochrome sprite bitmap for the specified text.
    // Load in batches for speed.
    function cloudSprite(contextAndRatio, d, data, di) {
      if (d.sprite) return;
      var c = contextAndRatio.context,
          ratio = contextAndRatio.ratio;

      c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
      var x = 0,
          y = 0,
          maxh = 0,
          n = data.length;
      --di;
      while (++di < n) {
        d = data[di];
        c.save();
        c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
        var w = c.measureText(d.text + "m").width * ratio,
            h = d.size << 1;
        if (d.rotate) {
          var sr = Math.sin(d.rotate * cloudRadians),
              cr = Math.cos(d.rotate * cloudRadians),
              wcr = w * cr,
              wsr = w * sr,
              hcr = h * cr,
              hsr = h * sr;
          w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;
          h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
        } else {
          w = (w + 0x1f) >> 5 << 5;
        }
        if (h > maxh) maxh = h;
        if (x + w >= (cw << 5)) {
          x = 0;
          y += maxh;
          maxh = 0;
        }
        if (y + h >= ch) break;
        c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
        if (d.rotate) c.rotate(d.rotate * cloudRadians);
        c.fillText(d.text, 0, 0);
        if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);
        c.restore();
        d.width = w;
        d.height = h;
        d.xoff = x;
        d.yoff = y;
        d.x1 = w >> 1;
        d.y1 = h >> 1;
        d.x0 = -d.x1;
        d.y0 = -d.y1;
        d.hasText = true;
        x += w;
      }
      var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
          sprite = [];
      while (--di >= 0) {
        d = data[di];
        if (!d.hasText) continue;
        var w = d.width,
            w32 = w >> 5,
            h = d.y1 - d.y0;
        // Zero the buffer
        for (var i = 0; i < h * w32; i++) sprite[i] = 0;
        x = d.xoff;
        if (x == null) return;
        y = d.yoff;
        var seen = 0,
            seenRow = -1;
        for (var j = 0; j < h; j++) {
          for (var i = 0; i < w; i++) {
            var k = w32 * j + (i >> 5),
                m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;
            sprite[k] |= m;
            seen |= m;
          }
          if (seen) seenRow = j;
          else {
            d.y0++;
            h--;
            j--;
            y++;
          }
        }
        d.y1 = d.y0 + seenRow;
        d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
      }
    }

    // Use mask-based collision detection.
    function cloudCollide(tag, board, sw) {
      sw >>= 5;
      var sprite = tag.sprite,
          w = tag.width >> 5,
          lx = tag.x - (w << 4),
          sx = lx & 0x7f,
          msx = 32 - sx,
          h = tag.y1 - tag.y0,
          x = (tag.y + tag.y0) * sw + (lx >> 5),
          last;
      for (var j = 0; j < h; j++) {
        last = 0;
        for (var i = 0; i <= w; i++) {
          if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))
              & board[x + i]) return true;
        }
        x += sw;
      }
      return false;
    }

    function cloudBounds(bounds, d) {
      var b0 = bounds[0],
          b1 = bounds[1];
      if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
      if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
      if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
      if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
    }

    function collideRects(a, b) {
      return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
    }

    function archimedeanSpiral(size) {
      var e = size[0] / size[1];
      return function(t) {
        return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
      };
    }

    function rectangularSpiral(size) {
      var dy = 4,
          dx = dy * size[0] / size[1],
          x = 0,
          y = 0;
      return function(t) {
        var sign = t < 0 ? -1 : 1;
        // See triangular numbers: T_n = n * (n + 1) / 2.
        switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {
          case 0:  x += dx; break;
          case 1:  y += dy; break;
          case 2:  x -= dx; break;
          default: y -= dy; break;
        }
        return [x, y];
      };
    }

    // TODO reuse arrays?
    function zeroArray(n) {
      var a = [],
          i = -1;
      while (++i < n) a[i] = 0;
      return a;
    }

    function cloudCanvas() {
      return document.createElement("canvas");
    }

    function functor(d) {
      return typeof d === "function" ? d : function() { return d; };
    }

    var spirals = {
      archimedean: archimedeanSpiral,
      rectangular: rectangularSpiral
    };

    },{"d3-dispatch":2}],2:[function(require,module,exports){
    // https://d3js.org/d3-dispatch/ Version 1.0.3. Copyright 2017 Mike Bostock.
    (function (global, factory) {
    	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    	(factory((global.d3 = global.d3 || {})));
    }(this, (function (exports) {
    var noop = {value: function() {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    exports.dispatch = dispatch;

    Object.defineProperty(exports, '__esModule', { value: true });

    })));

    },{}]},{},[1])(1)
    });
    }(d3_layout_cloud));

    var cloud = /*@__PURE__*/getDefaultExportFromCjs(d3_layout_cloud.exports);

    /**
     * Renders cloud of tags/keywords. Uses [d3-cloud](https://www.npmjs.com/package/d3-cloud) for calculations.
     * Please notice, `series` data points should have `label` attribute. See example below.
     */
    function Cloud(props) {
        var _a;
        var className = props.className, layerWidth = props.layerWidth, layerHeight = props.layerHeight, _b = props.colors, colors = _b === void 0 ? defaultSchemeName : _b;
        var _c = React.useState({
            labels: [],
            series: []
        }), state = _c[0], setState = _c[1];
        React.useEffect(function () {
            var layerWidth = props.layerWidth, layerHeight = props.layerHeight, series = props.series, minY = props.minY, maxY = props.maxY, canvas = props.canvas, _a = props.font, font = _a === void 0 ? 'serif' : _a, _b = props.minFontSize, minFontSize = _b === void 0 ? 10 : _b, _c = props.maxFontSize, maxFontSize = _c === void 0 ? 100 : _c, _d = props.timeInterval, timeInterval = _d === void 0 ? 15 : _d, _e = props.fontStyle, fontStyle = _e === void 0 ? 'normal' : _e, _f = props.fontWeight, fontWeight = _f === void 0 ? 'normal' : _f, rotate = props.rotate, _g = props.spiral, spiral = _g === void 0 ? 'archimedean' : _g, _h = props.padding, padding = _h === void 0 ? 1 : _h, random = props.random;
            var scale = linear$1()
                .range([minFontSize, maxFontSize])
                .domain([minY, maxY]);
            var words = (series === null || series === void 0 ? void 0 : series.reduce(function (words, _a, seriesIndex) {
                var data = _a.data;
                data.forEach(function (point, pointIndex) {
                    words.push(__assign(__assign({}, point), { text: point.label, size: point.y, seriesIndex: seriesIndex, pointIndex: pointIndex }));
                });
                return words;
            }, [])) || [];
            var cl = cloud()
                .size([layerWidth, layerHeight])
                .words(words)
                .font(font)
                .fontStyle(fontStyle)
                .fontWeight(fontWeight)
                .spiral(spiral)
                .padding(padding)
                .timeInterval(timeInterval)
                .fontSize(function (p) { return scale(p.size); });
            if (!isUndefined(rotate)) {
                cl.rotate(rotate);
            }
            if (random) {
                cl.random(random);
            }
            if (canvas) {
                cl.canvas(canvas);
            }
            cl.on('end', function (cloudLabels) {
                var labels = cloudLabels.reduce(function (labels, label) {
                    labels[label.seriesIndex] = labels[label.seriesIndex] || [];
                    labels[label.seriesIndex][label.pointIndex] = label;
                    return labels;
                }, []);
                setState({ series: series, labels: labels });
            });
            cl.start();
        }, [
            setState, layerWidth, layerHeight,
            props.series, props.minY, props.maxY, props.canvas, props.timeInterval,
            props.font, props.minFontSize, props.maxFontSize, props.fontStyle, props.fontWeight,
            props.rotate, props.spiral, props.padding, props.random
        ]);
        var color = colorFunc(colors);
        return React__default['default'].createElement("g", { className: className, style: props.style, opacity: props.opacity, transform: 'translate(' + (layerWidth / 2) + ',' + (layerHeight / 2) + ')' }, (_a = state.series) === null || _a === void 0 ? void 0 : _a.map(function (series, seriesIndex) {
            if ('seriesVisible' in props) {
                var seriesVisible = value(props.seriesVisible, { seriesIndex: seriesIndex, series: series, props: props });
                if (!seriesVisible) {
                    return;
                }
            }
            var seriesAttributes = value(props.seriesAttributes, { seriesIndex: seriesIndex, series: series, props: props });
            var seriesStyle = value(props.seriesStyle, { seriesIndex: seriesIndex, series: series, props: props });
            return React__default['default'].createElement("g", __assign({ key: seriesIndex, className: className && (className + '-series ' + className + '-series-' + seriesIndex), style: seriesStyle, opacity: series.opacity }, seriesAttributes), series.data.map(function (point, pointIndex) {
                var _a, _b;
                var label = (_b = (_a = state.labels) === null || _a === void 0 ? void 0 : _a[seriesIndex]) === null || _b === void 0 ? void 0 : _b[pointIndex];
                if (!label) {
                    return;
                }
                if ('labelVisible' in props) {
                    var labelVisible = value(props.labelVisible, {
                        seriesIndex: seriesIndex,
                        pointIndex: pointIndex,
                        point: point,
                        label: label,
                        series: series,
                        props: props
                    });
                    if (!labelVisible) {
                        return;
                    }
                }
                var labelAttributes = value(props.labelAttributes, {
                    seriesIndex: seriesIndex,
                    pointIndex: pointIndex,
                    point: point,
                    label: label,
                    series: series,
                    props: props
                });
                var labelStyle = value([point.style, series.style, props.labelStyle], { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, label: label, series: series, props: props });
                return React__default['default'].createElement("g", { key: pointIndex, className: className && (className + '-label ' + className + '-label-' + +pointIndex), style: {
                        fontSize: label.size + 'px',
                        fontFamily: label.font
                    } },
                    React__default['default'].createElement("text", __assign({ transform: 'translate(' + label.x + ',' + label.y + '),rotate(' + label.rotate + ')', fill: point.color || series.color || color(seriesIndex), fillOpacity: point.opacity, textAnchor: 'middle', style: labelStyle }, labelAttributes), label.text));
            }));
        }));
    }

    var symbolsMap = {
        'circle': symbolCircle,
        'cross': symbolCross,
        'diamond': symbolDiamond,
        'square': symbolSquare,
        'triangle-down': symbolWye,
        'triangle-up': symbolTriangle,
        'star': symbolStar
    };
    var methods = {
        dots: renderCircle,
        dot: renderCircle,
        circles: renderCircle,
        circle: renderCircle,
        ellipses: renderEllipse,
        ellipse: renderEllipse,
        symbols: renderSymbol,
        symbol: renderSymbol,
        labels: renderLabel$1,
        label: renderLabel$1,
        path: renderPath
    };
    /**
     * Renders dots for your scatter plot.
     */
    function Dots(props) {
        var _a;
        var className = props.className, scaleX = props.scaleX, scaleY = props.scaleY, _b = props.colors, colors = _b === void 0 ? defaultSchemeName : _b;
        var x = scaleX.factory(props);
        var y = scaleY.factory(props);
        var rotate = scaleX.swap || scaleY.swap;
        var color = colorFunc(colors);
        return React__default['default'].createElement("g", { className: className, style: props.style, opacity: props.opacity }, (_a = props.series) === null || _a === void 0 ? void 0 : _a.map(function (series, index) {
            if ('seriesVisible' in props) {
                var seriesVisible = value(props.seriesVisible, { seriesIndex: index, series: series, props: props });
                if (!seriesVisible) {
                    return;
                }
            }
            var seriesAttributes = value(props.seriesAttributes, { seriesIndex: index, series: series, props: props });
            var seriesStyle = value(props.seriesStyle, { seriesIndex: index, series: series, props: props });
            return React__default['default'].createElement("g", __assign({ key: index, className: className && (className + '-series ' + className + '-series-' + index), style: seriesStyle, opacity: series.opacity }, seriesAttributes), series.data.map(function (point, pointIndex) {
                if (rotate) {
                    return renderDot(props, color, y(point.y), x(point.x), index, pointIndex, point);
                }
                else {
                    return renderDot(props, color, x(point.x), y(point.y), index, pointIndex, point);
                }
            }));
        }));
    }
    function renderDot(props, color, x, y, seriesIndex, pointIndex, point) {
        var className = props.className, _a = props.dotType, dotType = _a === void 0 ? 'circles' : _a;
        var series = props.series[seriesIndex];
        if ('dotVisible' in props) {
            var dotVisible = value(props.dotVisible, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
            if (!dotVisible) {
                return;
            }
        }
        var groupStyle = value(props.groupStyle, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var _dotType = value([dotType], {
            seriesIndex: seriesIndex,
            pointIndex: pointIndex,
            point: point,
            series: series,
            props: props
        });
        var dotAttributes = value(props.dotAttributes, {
            seriesIndex: seriesIndex,
            pointIndex: pointIndex,
            point: point,
            dotType: _dotType,
            series: series,
            props: props
        });
        var dotStyle = value([point.style, series.style, props.dotStyle], {
            seriesIndex: seriesIndex,
            pointIndex: pointIndex,
            point: point,
            dotType: _dotType,
            series: series,
            props: props
        });
        var dot;
        if (isFunction(props.dotRender)) {
            dot = props.dotRender({ seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, dotStyle: dotStyle, dotAttributes: dotAttributes, props: props, color: color });
        }
        else {
            if (isString(_dotType)) {
                dot = methods[_dotType] &&
                    methods[_dotType]({
                        seriesIndex: seriesIndex,
                        pointIndex: pointIndex,
                        point: point,
                        dotStyle: dotStyle,
                        dotAttributes: dotAttributes,
                        props: props,
                        color: color
                    });
            }
            else if (Array.isArray(_dotType)) {
                dot = _dotType.map(function (_dotType, key) {
                    return methods[_dotType]({
                        key: key,
                        seriesIndex: seriesIndex,
                        pointIndex: pointIndex,
                        point: point,
                        dotStyle: dotStyle,
                        dotAttributes: dotAttributes,
                        props: props,
                        color: color
                    });
                });
            }
            else {
                dot = null;
            }
        }
        return React__default['default'].createElement("g", { key: pointIndex, className: className && (className + "-dot " + className + "-dot-" + pointIndex), transform: "translate(" + x + " " + y + ")", style: groupStyle }, dot);
    }
    function renderCircle(_a) {
        var key = _a.key, seriesIndex = _a.seriesIndex, pointIndex = _a.pointIndex, point = _a.point, dotStyle = _a.dotStyle, dotAttributes = _a.dotAttributes, props = _a.props, color = _a.color;
        var className = props.className;
        var series = props.series[seriesIndex];
        var _b = props.circleRadius, circleRadius = _b === void 0 ? 4 : _b;
        var _circleRadius = value(circleRadius, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var circleAttributes = value(props.circleAttributes, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        return React__default['default'].createElement("circle", __assign({ key: key, className: className && (className + "-circle " + className + "-circle-" + seriesIndex + "-" + pointIndex), cx: 0, cy: 0, r: _circleRadius, style: dotStyle, fill: point.color || series.color || color(seriesIndex), fillOpacity: point.opacity }, dotAttributes, circleAttributes));
    }
    function renderEllipse(_a) {
        var key = _a.key, seriesIndex = _a.seriesIndex, pointIndex = _a.pointIndex, point = _a.point, dotStyle = _a.dotStyle, dotAttributes = _a.dotAttributes, props = _a.props, color = _a.color;
        var className = props.className;
        var series = props.series[seriesIndex];
        var _b = props.ellipseRadiusX, ellipseRadiusX = _b === void 0 ? 6 : _b, _c = props.ellipseRadiusY, ellipseRadiusY = _c === void 0 ? 4 : _c;
        var _ellipseRadiusX = value(ellipseRadiusX, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var _ellipseRadiusY = value(ellipseRadiusY, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var ellipseAttributes = value(props.ellipseAttributes, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        return React__default['default'].createElement("ellipse", __assign({ key: key, className: className && (className + '-ellipse ' +
                className + '-ellipse-' + seriesIndex + '-' + pointIndex), cx: 0, cy: 0, rx: _ellipseRadiusX, ry: _ellipseRadiusY, style: dotStyle, fill: point.color || series.color || color(seriesIndex), fillOpacity: point.opacity }, dotAttributes, ellipseAttributes));
    }
    function renderPath(_a) {
        var key = _a.key, seriesIndex = _a.seriesIndex, pointIndex = _a.pointIndex, point = _a.point, dotStyle = _a.dotStyle, dotAttributes = _a.dotAttributes, props = _a.props, color = _a.color;
        var className = props.className;
        var series = props.series[seriesIndex];
        var path = value(props.path, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var pathAttributes = value(props.pathAttributes, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        return React__default['default'].createElement("path", __assign({ key: key, className: className && (className + '-path ' + className + '-path-' + seriesIndex + '-' + pointIndex), d: path, style: dotStyle, fill: point.color || series.color || color(seriesIndex), fillOpacity: point.opacity }, dotAttributes, pathAttributes));
    }
    function renderSymbol(_a) {
        var key = _a.key, seriesIndex = _a.seriesIndex, pointIndex = _a.pointIndex, point = _a.point, dotStyle = _a.dotStyle, dotAttributes = _a.dotAttributes, props = _a.props, color = _a.color;
        var className = props.className;
        var series = props.series[seriesIndex];
        var symbolType = value(props.symbolType, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var symbolAttributes = value(props.symbolAttributes, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var type = isString(symbolType) ? symbolsMap[symbolType] : symbolType;
        return React__default['default'].createElement("path", __assign({ key: key, className: className && (className + '-symbol ' + className + '-symbol-' + seriesIndex + '-' + pointIndex), d: symbol().type(type)(point, pointIndex), style: dotStyle, fill: point.color || series.color || color(seriesIndex), fillOpacity: point.opacity }, dotAttributes, symbolAttributes));
    }
    function renderLabel$1(_a) {
        var key = _a.key, seriesIndex = _a.seriesIndex, pointIndex = _a.pointIndex, point = _a.point, dotStyle = _a.dotStyle, dotAttributes = _a.dotAttributes, props = _a.props, color = _a.color;
        var className = props.className;
        var series = props.series[seriesIndex];
        var label = value(props.label, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var labelAttributes = value(props.labelAttributes, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        return React__default['default'].createElement("text", __assign({ key: key, className: className && (className + '-label ' + className + '-label-' + seriesIndex + '-' + pointIndex), style: dotStyle, fill: point.color || series.color || color(seriesIndex), fillOpacity: point.opacity }, dotAttributes, labelAttributes), label);
    }

    function DropShadow(_a) {
        var id = _a.id, _b = _a.dx, dx = _b === void 0 ? 1 : _b, _c = _a.dy, dy = _c === void 0 ? 1 : _c, _d = _a.blurDeviation, blurDeviation = _d === void 0 ? 4 : _d, _e = _a.blurIn, blurIn = _e === void 0 ? 'SourceAlpha' : _e;
        return React__default['default'].createElement("filter", { id: id },
            React__default['default'].createElement("feGaussianBlur", { "in": blurIn, stdDeviation: blurDeviation }),
            React__default['default'].createElement("feOffset", { dx: dx, dy: dy }),
            React__default['default'].createElement("feMerge", null,
                React__default['default'].createElement("feMergeNode", null),
                React__default['default'].createElement("feMergeNode", { "in": 'SourceGraphic' })));
    }

    var counter = 0;
    /**
     * Wrapper around standard svg linearGradient and radialGradient.
     */
    function Gradient(_a) {
        var _b = _a.type, type = _b === void 0 ? 'linear' : _b, _c = _a.idPrefix, idPrefix = _c === void 0 ? 'chartGradient' : _c, _d = _a.gradientUnits, gradientUnits = _d === void 0 ? 'objectBoundingBox' : _d, _e = _a.spreadMethod, spreadMethod = _e === void 0 ? 'pad' : _e, 
        // for linear gradient
        _f = _a.from, 
        // for linear gradient
        from = _f === void 0 ? ['0%', '0%'] : _f, _g = _a.to, to = _g === void 0 ? ['100%', '0%'] : _g, 
        // for radial gradient
        _h = _a.center, 
        // for radial gradient
        center = _h === void 0 ? ['50%', '50%'] : _h, props = __rest(_a, ["type", "idPrefix", "gradientUnits", "spreadMethod", "from", "to", "center"]);
        var id = React.useMemo(function () {
            if (props.id) {
                return props.id;
            }
            counter++;
            return idPrefix + counter;
        }, [props.id, idPrefix]);
        if (type === 'radial') {
            var focalPoint = props.focalPoint, radius = props.radius, gradientTransform = props.gradientTransform, cx = props.cx, cy = props.cy, fx = props.fx, fy = props.fy, r = props.r;
            var _cx = isUndefined(cx) ? (center && center[0]) : cx;
            var _cy = isUndefined(cy) ? (center && center[1]) : cy;
            var _fx = isUndefined(fx) ? (focalPoint && focalPoint[0]) : fx;
            var _fy = isUndefined(fy) ? (focalPoint && focalPoint[1]) : fy;
            var _r = isUndefined(r) ? radius : r;
            return React__default['default'].createElement("radialGradient", { id: id, gradientUnits: gradientUnits, gradientTransform: gradientTransform, spreadMethod: spreadMethod, cx: _cx, cy: _cy, fx: _fx, fy: _fy, r: _r }, props.children);
        }
        else {
            var gradientTransform = props.gradientTransform, x1 = props.x1, y1 = props.y1, x2 = props.x2, y2 = props.y2;
            var _x1 = isUndefined(x1) ? (from && from[0]) : x1;
            var _y1 = isUndefined(y1) ? (from && from[1]) : y1;
            var _x2 = isUndefined(x2) ? (to && to[0]) : x2;
            var _y2 = isUndefined(y2) ? (to && to[1]) : y2;
            return React__default['default'].createElement("linearGradient", { id: id, gradientUnits: gradientUnits, gradientTransform: gradientTransform, spreadMethod: spreadMethod, x1: _x1, y1: _y1, x2: _x2, y2: _y2 }, props.children);
        }
    }

    /**
     * Helps to use mouse events. For now supports only `onClick`, `onMouseMove` and `onMouseLeave`.
     *
     * This component will be improved and simplified in the future.
     */
    function Handlers(props) {
        var className = props.className, layerWidth = props.layerWidth, layerHeight = props.layerHeight;
        var onClick = props.onClick, onMouseMove = props.onMouseMove, onMouseLeave = props.onMouseLeave;
        var x = props.scaleX.factory(props);
        var y = props.scaleY.factory(props);
        var scaleX = props.scaleX.factory(props);
        var scaleY = props.scaleY.factory(props);
        var xDomain = x.domain();
        var xRange = x.range();
        x.domain(xRange);
        x.range(xDomain);
        var yDomain = y.domain();
        var yRange = y.range();
        y.domain(yRange);
        y.range(yDomain);
        var rectRef = React.useRef();
        var ratio = Math.abs((y(1) - y(0)) / (x(1) - x(0)));
        function handleMouseEvent(handler, event) {
            if (!rectRef.current) {
                return;
            }
            var rect = rectRef.current.getBoundingClientRect();
            var left = rect.left, top = rect.top, width = rect.width, height = rect.height;
            var clientX = event.clientX, clientY = event.clientY;
            var series = props.series, _a = props.sensitivity, sensitivity = _a === void 0 ? Infinity : _a, _b = props.optimized, optimized = _b === void 0 ? true : _b, layerWidth = props.layerWidth, layerHeight = props.layerHeight;
            var realX = (clientX - left) * layerWidth / width;
            var realY = (clientY - top) * layerHeight / height;
            var _x = x(realX);
            var _y = y(realY);
            var closestPoints = [];
            var minDistance = sensitivity;
            series === null || series === void 0 ? void 0 : series.forEach(function (series, seriesIndex) {
                var _a;
                (_a = series.data) === null || _a === void 0 ? void 0 : _a.forEach(function (point, pointIndex) {
                    var distance;
                    switch (props.distance) {
                        case 'x':
                            distance = Math.abs(point.x - _x);
                            break;
                        case 'y':
                            distance = Math.abs(point.y - _y);
                            break;
                        default:
                            distance = Math.sqrt(Math.pow(Math.abs(point.x - _x) * (ratio || 1), 2) +
                                Math.pow(Math.abs(point.y - _y), 2));
                            break;
                    }
                    if (!optimized || distance <= minDistance) {
                        minDistance = distance;
                        closestPoints.push({
                            seriesIndex: seriesIndex,
                            pointIndex: pointIndex,
                            point: point,
                            distance: distance
                        });
                    }
                });
            });
            closestPoints = sortBy(closestPoints, 'distance');
            handler({
                clientX: realX,
                clientY: realY,
                scaleX: scaleX,
                scaleY: scaleY,
                x: _x, y: _y,
                closestPoints: closestPoints,
                originalEvent: event
            });
        }
        var children = proxyChildren(props.children, props, {
            layerWidth: layerWidth,
            layerHeight: layerHeight,
            scaleX: props.scaleX,
            scaleY: props.scaleY
        });
        return React__default['default'].createElement("g", { className: className, onClick: onClick && handleMouseEvent.bind(null, onClick), onMouseMove: onMouseMove && handleMouseEvent.bind(null, onMouseMove), onMouseLeave: onMouseLeave },
            React__default['default'].createElement("rect", { ref: rectRef, x: 0, y: 0, width: layerWidth, height: layerHeight, fill: 'transparent', stroke: 'transparent' }),
            children);
    }

    /**
     * Creates a new layer using specific `width` and `height` at specific `position`. It's useful when
     * you have two or more graphics on the same chart. Or in case you to have a margins.
     */
    function Layer(_a) {
        var _b = _a.width, width = _b === void 0 ? '100%' : _b, _c = _a.height, height = _c === void 0 ? '100%' : _c, _d = _a.position, position = _d === void 0 ? 'middle center' : _d, layerWidth = _a.layerWidth, layerHeight = _a.layerHeight, className = _a.className, scaleX = _a.scaleX, scaleY = _a.scaleY, style = _a.style, props = __rest(_a, ["width", "height", "position", "layerWidth", "layerHeight", "className", "scaleX", "scaleY", "style"]);
        var _width = React.useMemo(function () {
            return normalizeNumber(width, layerWidth);
        }, [width, props.layerWidth]);
        var _height = React.useMemo(function () {
            return normalizeNumber(height, layerHeight);
        }, [height, props.layerHeight]);
        var _e = React.useMemo(function () {
            return getCoords(position, layerWidth, layerHeight, _width, _height);
        }, [position, layerWidth, layerHeight, _width, _height]), x = _e.x, y = _e.y;
        var children = proxyChildren(props.children, props, {
            layerWidth: _width,
            layerHeight: _height,
            scaleX: scaleX,
            scaleY: scaleY
        });
        return React__default['default'].createElement("g", { className: className, transform: "translate(" + x + " " + y + ")", style: style }, children);
    }

    /**
     * Renders labels for dots. Internally it's just a wrapper for [`<Dots>`](#dots) component
     * with `dotType="circle"`.
     */
    function Labels(props) {
        return (React__default['default'].createElement(Dots, __assign({}, props, { dotType: 'labels' })));
    }

    /**
     * Renders lines for your line chart.
     */
    function Lines(props) {
        var className = props.className, style = props.style, scaleX = props.scaleX, scaleY = props.scaleY, minY = props.minY, asAreas = props.asAreas, _a = props.colors, colors = _a === void 0 ? defaultSchemeName : _a, series = props.series, opacity = props.opacity, _b = props.interpolation, interpolation = _b === void 0 ? 'monotone' : _b, _c = props.lineWidth, lineWidth = _c === void 0 ? 3 : _c;
        var rotate = scaleX.swap || scaleY.swap;
        var x = scaleX.factory(props);
        var y = scaleY.factory(props);
        var _y0 = y(minY || 0);
        var color = colorFunc(colors);
        return React__default['default'].createElement("g", { className: className, style: style, opacity: opacity }, series === null || series === void 0 ? void 0 : series.map(function (series, index) {
            if ('seriesVisible' in props) {
                var seriesVisible = value(props.seriesVisible, { seriesIndex: index, series: series, props: props });
                if (!seriesVisible) {
                    return;
                }
            }
            var seriesAttributes = value(props.seriesAttributes, { seriesIndex: index, series: series, props: props });
            var seriesStyle = value(props.seriesStyle, { seriesIndex: index, series: series, props: props });
            var lineVisible = !('lineVisible' in props)
                || value(props.lineVisible, { seriesIndex: index, series: series, props: props });
            var linePath;
            if (lineVisible) {
                var line = void 0;
                if (rotate) {
                    line = asAreas ?
                        d3Area()
                            .x0(function (point) { return point.y0 ? y(point.y0) : _y0; })
                            .x1(function (point) { return y(point.y); }) :
                        d3Line()
                            .x(function (point) { return y(point.y); });
                    line.y(function (point) { return x(point.x); });
                }
                else {
                    line = asAreas ?
                        d3Area()
                            .y0(function (point) { return point.y0 ? y(point.y0) : _y0; })
                            .y1(function (point) { return y(point.y); }) :
                        d3Line()
                            .y(function (point) { return y(point.y); });
                    line.x(function (point) { return x(point.x); });
                }
                var lineColor = series.color || color(index);
                var curve = isString(interpolation) ? curves[interpolation] : interpolation;
                line.defined(function (point) { return isNumber(point.y); }).curve(curve);
                var lineAttributes = value(props.lineAttributes, { seriesIndex: index, series: series, props: props });
                var lineStyle = value([series.style, props.lineStyle], { seriesIndex: index, series: series, props: props });
                var _lineWidth = value(lineWidth, { seriesIndex: index, series: series, props: props });
                linePath = React__default['default'].createElement("path", __assign({ style: lineStyle, fill: asAreas ? lineColor : 'transparent', stroke: asAreas ? 'transparent' : lineColor, strokeWidth: _lineWidth, d: line(series.data) }, lineAttributes));
            }
            return React__default['default'].createElement("g", __assign({ key: index, className: className && (className + "-series " + className + "-series-" + index), style: seriesStyle, opacity: series.opacity }, seriesAttributes), linePath);
        }));
    }

    var maxAngle = 2 * Math.PI;
    /**
     * Renders pies for you pie chart or donut chart
     */
    function Pies(props) {
        var _a;
        var className = props.className, style = props.style, minX = props.minX, maxX = props.maxX, minY = props.minY, maxY = props.maxY, _b = props.position, position = _b === void 0 ? 'center middle' : _b, layerWidth = props.layerWidth, layerHeight = props.layerHeight, _c = props.colors, colors = _c === void 0 ? defaultSchemeName : _c, opacity = props.opacity, _d = props.startAngle, startAngle = _d === void 0 ? 0 : _d, _e = props.endAngle, endAngle = _e === void 0 ? maxAngle : _e, _f = props.padAngle, padAngle = _f === void 0 ? 0 : _f;
        var outerRadius = Math.min(props.layerWidth, props.layerHeight) / 2;
        var innerRadius = normalizeNumber(props.innerRadius, outerRadius);
        var innerPadding = normalizeNumber(props.innerPadding, outerRadius);
        var groupPadding = normalizeNumber(props.groupPadding, outerRadius);
        var radialScale = linear$1()
            .range([outerRadius, innerRadius])
            .domain(props.scaleX.direction >= 0 ? [minX - 0.5, maxX + 0.5] : [maxX + 0.5, minX - 0.5]);
        var circularScale = linear$1()
            .range([startAngle, endAngle])
            .domain(props.scaleY.direction >= 0 ? [minY, maxY] : [maxY, minY]);
        var baseWidth = Math.abs(radialScale(1) - radialScale(0));
        var pieWidth = (function () {
            if (props.pieWidth) {
                return normalizeNumber(props.pieWidth, outerRadius);
            }
            else {
                if (props.combined) {
                    return baseWidth - innerPadding;
                }
                else {
                    var seriesCount = !(props === null || props === void 0 ? void 0 : props.series) ? 1 : props.series.length;
                    return (baseWidth - groupPadding) / seriesCount - innerPadding;
                }
            }
        })();
        var _startAngle = circularScale(0);
        var color = colorFunc(colors);
        var coords = getCoords(position || '', layerWidth, layerHeight, outerRadius * 2, outerRadius * 2);
        var halfPadAngle = padAngle / 2 || 0;
        return React__default['default'].createElement("g", { className: className, style: style, transform: "translate(" + (coords.x + outerRadius) + " " + (coords.y + outerRadius) + ")", opacity: opacity }, (_a = props.series) === null || _a === void 0 ? void 0 : _a.map(function (series, index) {
            var _a;
            if ('seriesVisible' in props) {
                var seriesVisible = value(props.seriesVisible, { seriesIndex: index, series: series, props: props });
                if (!seriesVisible) {
                    return;
                }
            }
            var seriesAttributes = value(props.seriesAttributes, { seriesIndex: index, series: series, props: props });
            var seriesStyle = value(props.seriesStyle, { seriesIndex: index, series: series, props: props });
            var deltaRadial = 0;
            if (!props.combined) {
                deltaRadial = pieWidth * index - (props.series.length - 1) * 0.5 * pieWidth +
                    (index - (props.series.length - 1) / 2) * innerPadding;
            }
            return React__default['default'].createElement("g", __assign({ key: index, className: className && (className + '-series ' + className + '-series-' + index), style: seriesStyle, opacity: series.opacity }, seriesAttributes), (_a = series.data) === null || _a === void 0 ? void 0 : _a.map(function (point, pointIndex) {
                var startAngle = (point.y0 ? circularScale(point.y0) : _startAngle) + halfPadAngle;
                var endAngle = circularScale(point.y) - halfPadAngle;
                var radius = radialScale(point.x) - deltaRadial * (props.scaleX.direction || 1);
                return renderArc({
                    startAngle: startAngle,
                    endAngle: endAngle,
                    radius: radius,
                    pieWidth: pieWidth,
                    seriesIndex: index,
                    pointIndex: pointIndex,
                    point: point,
                    props: props,
                    color: color
                });
            }));
        }));
    }
    function renderArc(_a) {
        var startAngle = _a.startAngle, endAngle = _a.endAngle, radius = _a.radius, pieWidth = _a.pieWidth, seriesIndex = _a.seriesIndex, pointIndex = _a.pointIndex, point = _a.point, props = _a.props, color = _a.color;
        var className = props.className, _b = props.gradientStep, gradientStep = _b === void 0 ? 0.01 : _b;
        var series = props.series[seriesIndex];
        if ('pieVisible' in props) {
            var pieVisible = value(props.pieVisible, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
            if (!pieVisible) {
                return;
            }
        }
        var halfWidth = pieWidth / 2;
        var cornerRadius = value(props.cornerRadius, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var arc = d3Arc()
            .cornerRadius(normalizeNumber(cornerRadius, pieWidth))
            .padRadius(10)
            .innerRadius(radius - halfWidth)
            .outerRadius(radius + halfWidth);
        var fillColor = point.color || series.color || color(seriesIndex);
        if (Array.isArray(fillColor) && Array.from(new Set(fillColor)).length === 1) {
            fillColor = fillColor[0];
        }
        var pieStyle = value([point.style, series.style, props.pieStyle], {
            seriesIndex: seriesIndex,
            pointIndex: pointIndex,
            point: point,
            series: series,
            props: props
        });
        var pieAttributes = value(props.pieAttributes, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        var pathProps = __assign({ style: pieStyle, fill: fillColor, fillOpacity: point.opacity }, pieAttributes);
        var pathList = [];
        // fill color interpolation
        if (Array.isArray(fillColor)) {
            var interpolateAngle_1 = interpolate(startAngle, endAngle);
            fillColor.forEach(function (color, index) {
                if (index === fillColor.length - 1) {
                    return;
                }
                var interpolateFillColor = interpolate(color, fillColor[index + 1]);
                var step = 1 / ((endAngle - startAngle) / gradientStep);
                for (var i = 0; i < 1; i += step) {
                    pathProps.fill = interpolateFillColor(i);
                    var angleIndex = (index + i) / (fillColor.length - 1);
                    pathList = pathList.concat(renderArcPart({
                        startAngle: interpolateAngle_1(angleIndex),
                        endAngle: interpolateAngle_1(angleIndex + step),
                        maxAngle: maxAngle,
                        pathProps: pathProps,
                        arc: arc,
                        key: i
                    }));
                }
            });
        }
        else {
            pathList = renderArcPart({
                startAngle: startAngle,
                endAngle: endAngle,
                maxAngle: maxAngle,
                pathProps: pathProps,
                arc: arc,
                key: pointIndex
            });
        }
        var groupStyle = value(props.groupStyle, { seriesIndex: seriesIndex, pointIndex: pointIndex, point: point, series: series, props: props });
        return React__default['default'].createElement("g", { key: pointIndex, className: className && (className + '-pie ' + className + '-pie-' + pointIndex), style: groupStyle }, pathList);
    }
    function renderArcPart(_a) {
        var startAngle = _a.startAngle, endAngle = _a.endAngle, maxAngle = _a.maxAngle, pathProps = _a.pathProps, arc = _a.arc, key = _a.key;
        var pathList = [];
        while (endAngle >= 4 * Math.PI) {
            endAngle -= 2 * Math.PI;
            if (endAngle < startAngle) {
                startAngle -= 2 * Math.PI;
            }
        }
        var lapsCount = Math.abs((endAngle - startAngle) / maxAngle);
        var lapIndex = 0;
        while (lapIndex < lapsCount) {
            var d = arc({
                startAngle: startAngle,
                endAngle: Math.min(startAngle + maxAngle, endAngle)
            });
            startAngle += maxAngle;
            pathList.push(React__default['default'].createElement("path", __assign({ key: '' + key + lapIndex }, pathProps, { d: d })));
            lapIndex++;
        }
        return pathList;
    }

    /**
     * Renders radial lines for your radar chart
     */
    function RadialLines(props) {
        var className = props.className, style = props.style, asAreas = props.asAreas, _a = props.colors, colors = _a === void 0 ? defaultSchemeName : _a, minX = props.minX, maxX = props.maxX, minY = props.minY, maxY = props.maxY, _b = props.position, position = _b === void 0 ? 'center middle' : _b, layerWidth = props.layerWidth, layerHeight = props.layerHeight, opacity = props.opacity, series = props.series, _c = props.interpolation, interpolation = _c === void 0 ? 'cardinal-closed' : _c, _d = props.startAngle, startAngle = _d === void 0 ? 0 : _d, _e = props.endAngle, endAngle = _e === void 0 ? 2 * Math.PI : _e, _f = props.lineWidth, lineWidth = _f === void 0 ? 3 : _f, _g = props.innerRadius, innerRadius = _g === void 0 ? 0 : _g;
        var _outerRadius = Math.min(props.layerWidth, props.layerHeight) / 2;
        var _innerRadius = normalizeNumber(innerRadius, _outerRadius);
        var radialScale = linear$1()
            .range([_innerRadius, _outerRadius])
            .domain(props.scaleY.direction >= 0 ? [minY, maxY] : [maxY, minY]);
        var circularScale = linear$1()
            .range([startAngle, endAngle])
            .domain(props.scaleX.direction >= 0 ? [minX - 0.5, maxX + 0.5] : [maxX + 0.5, minX - 0.5]);
        var _radius0 = radialScale(0);
        var coords = getCoords(position || '', layerWidth, layerHeight, _outerRadius * 2, _outerRadius * 2);
        var color = colorFunc(colors);
        return React__default['default'].createElement("g", { className: className, style: style, transform: 'translate(' + (coords.x + _outerRadius) + ' ' + (coords.y + _outerRadius) + ')', opacity: opacity }, series === null || series === void 0 ? void 0 : series.map(function (series, index) {
            if ('seriesVisible' in props) {
                var seriesVisible = value(props.seriesVisible, { seriesIndex: index, series: series, props: props });
                if (!seriesVisible) {
                    return;
                }
            }
            var seriesAttributes = value(props.seriesAttributes, { seriesIndex: index, series: series, props: props });
            var seriesStyle = value(props.seriesStyle, { seriesIndex: index, series: series, props: props });
            var linePath;
            var lineVisible = !('lineVisible' in props)
                || value(props.lineVisible, { seriesIndex: index, series: series, props: props });
            if (lineVisible) {
                var line = asAreas ?
                    areaRadial()
                        .innerRadius(function (point) { return point.y0 ? radialScale(point.y0) : _radius0; })
                        .outerRadius(function (point) { return radialScale(point.y); }) :
                    lineRadial$1()
                        .radius(function (point) { return radialScale(point.y); });
                var lineColor = series.color || color(index);
                var curve = isString(interpolation) ? curves[interpolation] : interpolation;
                line.angle(function (point) { return circularScale(point.x); })
                    .defined(function (point) { return isNumber(point.y); })
                    .curve(curve);
                var lineAttributes = value(props.lineAttributes, { seriesIndex: index, series: series, props: props });
                var lineStyle = value([series.style, props.lineStyle], { seriesIndex: index, series: series, props: props });
                var _lineWidth = value(lineWidth, { seriesIndex: index, series: series, props: props });
                linePath = React__default['default'].createElement("path", __assign({ style: lineStyle, fill: asAreas ? lineColor : 'transparent', stroke: asAreas ? 'transparent' : lineColor, strokeWidth: _lineWidth, d: line(series.data) }, lineAttributes));
            }
            return React__default['default'].createElement("g", __assign({ key: index, className: className && (className + "-series " + className + "-series-" + index), style: seriesStyle, opacity: series.opacity }, seriesAttributes), linePath);
        }));
    }

    /**
     * Renders ticks (labels and lines) for axis (x and y).
     */
    function Ticks(props) {
        var className = props.className, scaleX = props.scaleX, scaleY = props.scaleY, _a = props.axis, axis = _a === void 0 ? 'x' : _a, style = props.style;
        var x = scaleX.factory(props);
        var y = scaleY.factory(props);
        var horizontal = (axis === 'y' && !scaleX.swap && !scaleY.swap) ||
            (axis === 'x' && (scaleX.swap || scaleY.swap));
        var position = props.position ||
            (axis === 'x' ?
                (scaleX.swap || scaleY.swap ? 'top' : 'bottom') :
                'left');
        var ticks1 = value([props.ticks], props);
        var ticks2 = isNumber(ticks1) ? { maxTicks: ticks1 } : (ticks1 || {});
        var ticks = Array.isArray(ticks2) ? ticks2 : generateTicks(props, ticks2);
        return React__default['default'].createElement("g", { className: className, style: style, opacity: props.opacity }, ticks.map(function (tick, index) { return renderTick({
            ticksLength: ticks.length,
            tick: tick,
            index: index,
            x: x,
            y: y,
            horizontal: horizontal,
            position: position,
            props: props
        }); }));
    }
    function generateTicks(props, _a) {
        var maxTicks = _a.maxTicks, minDistance = _a.minDistance, distance = _a.distance;
        var axis = props.axis, maxX = props.maxX, maxY = props.maxY, minX = props.minX, minY = props.minY;
        var max = axis === 'y' ? maxY : maxX;
        var min = axis === 'y' ? minY : minX;
        var length = max - min;
        if (isUndefined(minDistance)) {
            minDistance = Math.min(1, length);
        }
        if (isUndefined(maxTicks)) {
            maxTicks = Math.min((length + minDistance) / minDistance, 5);
        }
        if (isUndefined(distance)) {
            distance = Math.max(minDistance, length / maxTicks);
            distance = Math.ceil(distance / minDistance) * minDistance;
        }
        var result = [];
        for (var i = min; i < max + minDistance; i += distance) {
            result.push(i);
        }
        return result;
    }
    function renderTick(_a) {
        var _b;
        var ticksLength = _a.ticksLength, _tick = _a.tick, index = _a.index, x = _a.x, y = _a.y, horizontal = _a.horizontal, position = _a.position, props = _a.props;
        var axis = props.axis, className = props.className, layerWidth = props.layerWidth, layerHeight = props.layerHeight, scaleX = props.scaleX, scaleY = props.scaleY;
        var tick = isNumber(_tick) ? (_b = {}, _b[axis] = _tick, _b) : _tick;
        if ('tickVisible' in props) {
            var tickVisible = value(props.tickVisible, { index: index, ticksLength: ticksLength, tick: tick, props: props });
            if (!tickVisible) {
                return;
            }
        }
        var tickAttributes = value(props.tickAttributes, { index: index, ticksLength: ticksLength, tick: tick, props: props });
        var tickStyle = value(props.tickStyle, { index: index, ticksLength: ticksLength, tick: tick, props: props });
        var pX = axis === 'x' ? x(tick.x) : normalizeNumber(position, layerWidth);
        var pY = axis === 'y' ? y(tick.y) : normalizeNumber(position, layerHeight);
        var transform = (scaleX.swap || scaleY.swap) ?
            ('translate(' + pY + ' ' + pX + ')') :
            ('translate(' + pX + ' ' + pY + ')');
        return React__default['default'].createElement("g", __assign({ key: index, style: tickStyle, transform: transform, className: className && (className + '-tick ' + className + '-tick-' + index) }, tickAttributes),
            renderLabel({ ticksLength: ticksLength, tick: tick, index: index, props: props }),
            renderLine({ ticksLength: ticksLength, tick: tick, index: index, horizontal: horizontal, props: props }));
    }
    function renderLabel(_a) {
        var ticksLength = _a.ticksLength, tick = _a.tick, index = _a.index, props = _a.props;
        var className = props.className, axis = props.axis;
        if ('labelVisible' in props) {
            var labelVisible = value(props.labelVisible, { index: index, ticksLength: ticksLength, tick: tick, props: props });
            if (!labelVisible) {
                return;
            }
        }
        var labelAttributes = value([tick.labelAttributes, props.labelAttributes], { index: index, ticksLength: ticksLength, tick: tick, props: props });
        var labelStyle = value([tick.labelStyle, props.labelStyle], { index: index, ticksLength: ticksLength, tick: tick, props: props });
        var label = value([tick.label, props.label, tick[axis]], { index: index, ticksLength: ticksLength, tick: tick, props: props });
        if (isString(label) || isNumber(label)) {
            return React__default['default'].createElement("text", __assign({ style: labelStyle, className: className && (className + "-label " + className + "-label-" + index) }, labelAttributes), value(props.labelFormat, label + '') || label);
        }
        else {
            return label;
        }
    }
    function renderLine(_a) {
        var ticksLength = _a.ticksLength, tick = _a.tick, index = _a.index, horizontal = _a.horizontal, props = _a.props;
        var _b = props.lineLength, lineLength = _b === void 0 ? 5 : _b, _c = props.lineOffset, lineOffset = _c === void 0 ? 0 : _c, layerWidth = props.layerWidth, layerHeight = props.layerHeight, className = props.className;
        if ('lineVisible' in props) {
            var lineVisible = value(props.lineVisible, { index: index, ticksLength: ticksLength, tick: tick, props: props });
            if (!lineVisible) {
                return null;
            }
        }
        var lineAttributes = value([tick.lineAttributes, props.lineAttributes], { index: index, ticksLength: ticksLength, tick: tick, props: props });
        var lineStyle = value([tick.lineStyle, props.lineStyle], { index: index, ticksLength: ticksLength, tick: tick, props: props });
        var _lineLength = normalizeNumber(value([tick.lineLength, lineLength], { index: index, ticksLength: ticksLength, tick: tick, props: props }), horizontal ? layerWidth : layerHeight);
        var _lineOffset = normalizeNumber(value([tick.lineOffset, lineOffset], { index: index, ticksLength: ticksLength, tick: tick, props: props }), horizontal ? layerWidth : layerHeight);
        var d = horizontal ?
            ('M' + _lineOffset + ',0 h' + _lineLength) :
            ('M0,' + _lineOffset + ' v' + _lineLength);
        return React__default['default'].createElement("path", __assign({ style: lineStyle, className: className && (className + "-line " + className + "-line-" + index), d: d }, lineAttributes));
    }

    function Title(props) {
        var style = props.style, className = props.className, children = props.children;
        var _a = getCoords(props.position, props.layerWidth, props.layerHeight, props.width, props.height), x = _a.x, y = _a.y;
        return (React__default['default'].createElement("g", { className: className, transform: "translate(" + x + " " + y + ")", style: style }, isString(children)
            ? React__default['default'].createElement("text", { textAnchor: props.textAnchor }, children)
            : (isFunction(children) ? children(props) : children)));
    }

    /**
     * Transforms `series` data according chosen `method`.
     *
     * As a wrapper it takes `series` obtained from its parent and gives it to its children.
     */
    function Transform(props) {
        var className = props.className, layerWidth = props.layerWidth, layerHeight = props.layerHeight, scaleX = props.scaleX, scaleY = props.scaleY;
        var transformedProps = transform(props, props.method);
        var children = proxyChildren(props.children, transformedProps, {
            layerWidth: isUndefined(transformedProps.layerWidth) ? layerWidth : transformedProps.layerWidth,
            layerHeight: isUndefined(transformedProps.layerHeight) ? layerHeight : transformedProps.layerHeight,
            scaleX: isUndefined(transformedProps.scaleX) ? scaleX : transformedProps.scaleX,
            scaleY: isUndefined(transformedProps.scaleY) ? scaleY : transformedProps.scaleY
        });
        return (React__default['default'].createElement("g", { className: className }, children));
    }

    exports.Animate = Animate;
    exports.Bars = Bars;
    exports.Chart = Chart;
    exports.Cloud = Cloud;
    exports.Dots = Dots;
    exports.DropShadow = DropShadow;
    exports.Gradient = Gradient;
    exports.Handlers = Handlers;
    exports.Labels = Labels;
    exports.Layer = Layer;
    exports.Lines = Lines;
    exports.Pies = Pies;
    exports.RadialLines = RadialLines;
    exports.Ticks = Ticks;
    exports.Title = Title;
    exports.Transform = Transform;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
